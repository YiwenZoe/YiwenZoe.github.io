

<!DOCTYPE html>
<html lang="en" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>leetcode - Hexo</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="Leetcode 23. Merge k Sorted...">
  <meta name="author" content="Zoe">
  <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="https://at.alicdn.com/t/font_1445822_p6ry5n7lrr.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      loading: {
        gif: '/images/theme/loading.gif',
        lottie: ''
      },
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: {
          gif: '/images/theme/loading.gif',
          lottie: ''
        }
      },
      donate: {
        enable: true,
        alipay: 'https://pic.izhaoo.com/alipay.jpg',
        wechat: 'https://pic.izhaoo.com/wechat.jpg'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '我在开了灯的床头下，想问问自己的心啊。',
          typing: true,
          api: 'https://v2.jinrishici.com/one.json',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: false,
        path: ''
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 6.1.0"></head>

<body class="lock-screen">
  <div class="loading" id="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
    </div>
    <div class="center">leetcode</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/galleries/ " class="underline "> 摄影</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags/ " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/theme/post-image.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">leetcode</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>May 23, 2022</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>61692</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        
        <h4 id="Leetcode-23-Merge-k-Sorted-Lists"><a href="#Leetcode-23-Merge-k-Sorted-Lists" class="headerlink" title="Leetcode 23. Merge k Sorted Lists"></a>Leetcode 23. Merge k Sorted Lists</h4><ul>
<li>Approach 1: Brute Force<ul>
<li>Traverse all the linked lists and collect the values of the nodes into an array.</li>
<li>Sort this array</li>
<li>Create a new sorted linked list</li>
<li>Time complexity: O(NlogN) where N is the total number of nodes</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeKLists</span>(<span class="hljs-params">self, lists: <span class="hljs-type">List</span>[<span class="hljs-type">Optional</span>[ListNode]]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type lists: List(ListNode)</span><br><span class="hljs-string">        :rtypr: ListNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        nodes = []<br>        <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> lists:<br>            <span class="hljs-keyword">while</span> l:<br>                nodes.append(l.val)<br>                l = l.<span class="hljs-built_in">next</span><br>        <br>        nodes.sort()<br>        head = point = ListNode(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nodes:<br>            point.<span class="hljs-built_in">next</span> = ListNode(x)<br>            point = point.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> head.<span class="hljs-built_in">next</span><br><br></code></pre></td></tr></table></figure>


<ul>
<li>Approach 2: Merge with Divide And Conquer<ul>
<li>Pair up k lists and merge each pair</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeKLists</span>(<span class="hljs-params">self, lists: <span class="hljs-type">List</span>[<span class="hljs-type">Optional</span>[ListNode]]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge2Lists</span>(<span class="hljs-params">l1,l2</span>):<br>            head = point = ListNode(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">and</span> l2:<br>                <span class="hljs-keyword">if</span> l1.val &lt;= l2.val:<br>                    point.<span class="hljs-built_in">next</span> = l1<br>                    l1 = l1.<span class="hljs-built_in">next</span><br>                <span class="hljs-keyword">else</span>:<br>                    point.<span class="hljs-built_in">next</span> = l2<br>                    l2 = l2.<span class="hljs-built_in">next</span><br>                point = point.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> l1:<br>                point.<span class="hljs-built_in">next</span> = l1<br>            <span class="hljs-keyword">if</span> l2:<br>                point.<span class="hljs-built_in">next</span> = l2<br>            <span class="hljs-keyword">return</span> head.<span class="hljs-built_in">next</span><br>        <br><br>        length = <span class="hljs-built_in">len</span>(lists)<br>        interval = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> interval &lt; length:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, length-interval, interval * <span class="hljs-number">2</span>):<br>                lists[i] = merge2Lists(lists[i], lists[i+interval])<br>            interval *= <span class="hljs-number">2</span><br>        <br>        <span class="hljs-keyword">return</span> lists[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> length &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>

<ul>
<li>Approach 3: Heapq<ul>
<li>Overwrite the compare function, so that we can directly put ListNode into heap</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.next = None</span><br><br><span class="hljs-keyword">import</span> heapq<br><br><span class="hljs-comment"># ListNode.__lt__ = lambda x,y: (x.val &lt; y.val)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">self, other</span>):<br>    <span class="hljs-keyword">return</span> self.val &lt; other.val<br><br>ListNode.__lt__ = __lt__<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeKLists</span>(<span class="hljs-params">self, lists: <span class="hljs-type">List</span>[ListNode]</span>) -&gt; ListNode:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> lists:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <br>        heap = []<br>        <span class="hljs-keyword">for</span> head <span class="hljs-keyword">in</span> lists:<br>            <span class="hljs-keyword">if</span> head:<br>                heapq.heappush(heap, head)<br>        <br>        dummy = head = ListNode(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">while</span> heap:<br>            cur = heapq.heappop(heap)<br>            <span class="hljs-keyword">if</span> cur.<span class="hljs-built_in">next</span>:<br>                heapq.heappush(heap, cur.<span class="hljs-built_in">next</span>)<br>            head.<span class="hljs-built_in">next</span> = cur<br>            head = head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br>        <br></code></pre></td></tr></table></figure>


<h4 id="Leetcode-907"><a href="#Leetcode-907" class="headerlink" title="Leetcode 907"></a>Leetcode 907</h4><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><ul>
<li>如何用一个loop同时找到左右边界<ul>
<li>当while循环执行时，cur &lt;&#x3D; 所有栈顶元素，并且cur在所有栈顶元素右边，所以cur是所有栈顶元素的右边界。</li>
<li>当while循环退出时，找到了第一个栈顶元素 &lt; cur， 并且栈顶元素在cur左边, 所有left[i] &#x3D; stack[-1]<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sumSubarrayMins</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        mod = <span class="hljs-number">10</span> **<span class="hljs-number">9</span> + <span class="hljs-number">7</span><br>        stack = []<br>        n = <span class="hljs-built_in">len</span>(arr)<br>        left = [-<span class="hljs-number">1</span>] * n<br>        right = [n] * n<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            cur = arr[i]<br>            <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> cur &lt;= arr[stack[-<span class="hljs-number">1</span>]]:<br>                right[stack.pop()] = i<br>                <br>            <span class="hljs-keyword">if</span> stack:<br>                left[i] = stack[-<span class="hljs-number">1</span>]<br>             <br>            stack.append(i) <br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-comment"># l,r = left[i]+1, right[i]-1</span><br>            <span class="hljs-comment"># ans += arr[i] * (r+1-i) * (i+1-l)</span><br>            <span class="hljs-comment"># ans += arr[i] * (right[i]-i) * (i-left[i])</span><br>            ans += arr[i] * (right[i] * i - right[i]*left[i] - i*i + i*left[i]) % mod<br>        <span class="hljs-keyword">return</span> ans % mod<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="Leetcode-1856"><a href="#Leetcode-1856" class="headerlink" title="Leetcode 1856"></a>Leetcode 1856</h4><h4 id="单调栈-1"><a href="#单调栈-1" class="headerlink" title="单调栈"></a>单调栈</h4><ul>
<li>最后 % mod<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSumMinProduct</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        stack = []<br>        mod = <span class="hljs-number">10</span> **<span class="hljs-number">9</span> + <span class="hljs-number">7</span><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        left = [-<span class="hljs-number">1</span>] * n<br>        right = [n] * n<br>        pres = [<span class="hljs-number">0</span>]<br>        ans = <span class="hljs-number">0</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> nums[i] &lt;= nums[stack[-<span class="hljs-number">1</span>]]:<br>                right[stack.pop()] = i<br>            <br>            <span class="hljs-keyword">if</span> stack:<br>                left[i] = stack[-<span class="hljs-number">1</span>]<br>            <br>            stack.append(i)<br>        <br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>            pres.append(pres[-<span class="hljs-number">1</span>] + num)<br>        <br>        <span class="hljs-comment"># print(pres)</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            l,r = left[i]+<span class="hljs-number">1</span>, right[i]-<span class="hljs-number">1</span><br>            <span class="hljs-comment"># print(l,r)</span><br>            min_pro = nums[i] * (pres[r+<span class="hljs-number">1</span>] - pres[l])<br>            <span class="hljs-comment"># print(min_pro)</span><br>            ans = <span class="hljs-built_in">max</span>(ans, min_pro)<br>        <br>        <span class="hljs-keyword">return</span> ans % mod<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="Leetcode-1944"><a href="#Leetcode-1944" class="headerlink" title="Leetcode 1944."></a>Leetcode 1944.</h4><ul>
<li>Start from right to left</li>
<li>stack save the heights the current people meight see. And we will pop the heights the next people cannot see(heights &lt;&#x3D; current height).And add the current height if it is not the same as top height</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">canSeePersonsCount</span>(<span class="hljs-params">self, heights: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>	heights = heights[::-<span class="hljs-number">1</span>] <span class="hljs-comment"># we&#x27;ll go through the people from right to left</span><br>	reversed_result = []<br>	stack = [] <span class="hljs-comment"># holds the heights of the people a newly added person might see</span><br><br>	<span class="hljs-keyword">for</span> i, height <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(heights):<br>		seen_count = <span class="hljs-number">0</span> <span class="hljs-comment"># the number of people seen by the currently added person</span><br><br>		<span class="hljs-comment"># Person being added blocks sight of the popped heights for people to his left</span><br>		<span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> stack[-<span class="hljs-number">1</span>] &lt; height:<br>			stack.pop()<br>			seen_count += <span class="hljs-number">1</span><br><br>		<span class="hljs-comment"># There&#x27;s still someone ahead</span><br>		<span class="hljs-keyword">if</span> stack:<br>			seen_count += <span class="hljs-number">1</span><br><br>		<span class="hljs-comment"># Add self to stack if needed</span><br>		<span class="hljs-comment"># Note: we don&#x27;t want to keep two people of same height in the stack, because the person to the left will block the sight of the person to the right.</span><br>		<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> stack <span class="hljs-keyword">or</span> (stack <span class="hljs-keyword">and</span> stack[-<span class="hljs-number">1</span>] != height):<br>			stack.append(height)<br><br>		reversed_result.append(seen_count)<br><br>	<span class="hljs-keyword">return</span> reversed_result[::-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>


<h3 id="Arrays-and-Hashing"><a href="#Arrays-and-Hashing" class="headerlink" title="Arrays and Hashing"></a>Arrays and Hashing</h3><h4 id="Leetcode-49"><a href="#Leetcode-49" class="headerlink" title="Leetcode 49"></a>Leetcode 49</h4><h4 id="Hash-table"><a href="#Hash-table" class="headerlink" title="Hash table"></a>Hash table</h4><ul>
<li>Create an array to represent a string</li>
<li>Then create a hashmap use the tuple format of the array as the key and string as the value</li>
<li>Then we can find the string with the same characters</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">groupAnagrams</span>(<span class="hljs-params">self, strs: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]:<br>        hmap = collections.defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> st <span class="hljs-keyword">in</span> strs:<br>            array = [<span class="hljs-number">0</span>]*<span class="hljs-number">26</span><br>            <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> st:<br>                array[<span class="hljs-built_in">ord</span>(l) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)] += <span class="hljs-number">1</span><br>            hmap[<span class="hljs-built_in">tuple</span>(array)].append(st)<br>            <span class="hljs-comment"># print(hmap)</span><br>        <span class="hljs-keyword">return</span> hmap.values()<br></code></pre></td></tr></table></figure>

<h4 id="Leetcode-347"><a href="#Leetcode-347" class="headerlink" title="Leetcode 347"></a>Leetcode 347</h4><h4 id="Hash-table-1"><a href="#Hash-table-1" class="headerlink" title="Hash table"></a>Hash table</h4><ul>
<li>Create a list with index indicate the frequency of the element.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">topKFrequent</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        freq = [[] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n+<span class="hljs-number">1</span>)]<br>        <br>        d = &#123;&#125;<br>        <br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">if</span> n <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> d:<br>                d[n] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                d[n] += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">for</span> num, cnt <span class="hljs-keyword">in</span> d.items():<br>            freq[cnt].append(num)<br>        <br>        ans = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(freq)-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> freq[i]:<br>                ans.append(n)<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ans) == k:<br>                    <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure>


<h4 id="Leetcode-238"><a href="#Leetcode-238" class="headerlink" title="Leetcode 238"></a>Leetcode 238</h4><h4 id="Presum"><a href="#Presum" class="headerlink" title="Presum"></a>Presum</h4><ul>
<li>Create a table to stroe the product of numbers on the left side of number i<ul>
<li>leftproduct[i] &#x3D; leftproduct[i-1] * nums[i-1]</li>
</ul>
</li>
<li>Create a table to stroe the product of elements on the right side of number i<ul>
<li>rightproduct[i] &#x3D; rightproduct[i+1]*numsp[i+1]</li>
</ul>
</li>
<li>For the purpose to do not use extra space, we can combine leftproduct and rightproduct</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Method1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">productExceptSelf</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        length = <span class="hljs-built_in">len</span>(nums)<br>        productleft = [<span class="hljs-number">1</span>]*length<br>        productright = [<span class="hljs-number">1</span>]*length<br>                <br>        <span class="hljs-comment"># first calcaute the product on the left side</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,length):<br>            productleft[i] = productleft[i-<span class="hljs-number">1</span>]*nums[i-<span class="hljs-number">1</span>]<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length-<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>            productright[i] = productright[i+<span class="hljs-number">1</span>]*nums[i+<span class="hljs-number">1</span>]<br>        <br>        ans = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length):<br>            res = productleft[i] * productright[i]<br>            ans.append(res)<br>        <span class="hljs-keyword">return</span> ans<br><br><span class="hljs-comment"># Method2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">productExceptSelf</span>(<span class="hljs-params">self, nums</span>):<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        res = [<span class="hljs-number">1</span>] * n<br><br>        prefix = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            res[i] *= prefix<br>            prefix *= nums[i]<br>        <br>        postfix = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>            res[i] *= postfix<br>            postfix *= nums[i]<br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h3 id="Leetcode-36-Valid-Sudoku"><a href="#Leetcode-36-Valid-Sudoku" class="headerlink" title="Leetcode 36 Valid Sudoku"></a>Leetcode 36 Valid Sudoku</h3><ul>
<li>Hash table</li>
<li>separate the board into buckets</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidSudoku</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        cols = collections.defaultdict(<span class="hljs-built_in">set</span>)<br>        rows = collections.defaultdict(<span class="hljs-built_in">set</span>)<br>        squares = collections.defaultdict(<span class="hljs-built_in">set</span>)  <span class="hljs-comment"># key = (r /3, c /3)</span><br><br>        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>                <span class="hljs-keyword">if</span> board[r][c] == <span class="hljs-string">&quot;.&quot;</span>:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">if</span> (<br>                    board[r][c] <span class="hljs-keyword">in</span> rows[r]<br>                    <span class="hljs-keyword">or</span> board[r][c] <span class="hljs-keyword">in</span> cols[c]<br>                    <span class="hljs-keyword">or</span> board[r][c] <span class="hljs-keyword">in</span> squares[(r // <span class="hljs-number">3</span>, c // <span class="hljs-number">3</span>)]<br>                ):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                cols[c].add(board[r][c])<br>                rows[r].add(board[r][c])<br>                squares[(r // <span class="hljs-number">3</span>, c // <span class="hljs-number">3</span>)].add(board[r][c])<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>

<h3 id="Leetcode-128-Longest-Consecutive-Sequence"><a href="#Leetcode-128-Longest-Consecutive-Sequence" class="headerlink" title="Leetcode 128 Longest Consecutive Sequence"></a>Leetcode 128 Longest Consecutive Sequence</h3><ul>
<li>Method 1: Walk each streak</li>
<li>Method 2: Union Find</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Method 1: Walk each streak</span><br><span class="hljs-comment"># First turn the input into a set of numbers. That takes O(n) and then we can ask in O(1) whether we have a certain number.</span><br><br><span class="hljs-comment"># Then go through the numbers. If the number x is the start of a streak (i.e., x-1 is not in the set), then test y = x+1, x+2, x+3, ... and stop at the first number y not in the set. The length of the streak is then simply y-x and we update our global best with that. Since we check each streak only once, this is overall O(n). This ran in 44 ms on the OJ, one of the fastest Python submissions.</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestConsecutive</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># First take O(n) time to turn the list to set</span><br>        <span class="hljs-comment"># Set takes O(1) time to find a number</span><br>        nums = <span class="hljs-built_in">set</span>(nums)<br><br>        best = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-comment"># Find the head of a streak</span><br>            <span class="hljs-keyword">if</span> x-<span class="hljs-number">1</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> nums:<br>                y = x + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">while</span> y <span class="hljs-keyword">in</span> nums:<br>                    y += <span class="hljs-number">1</span><br>                best = <span class="hljs-built_in">max</span>(best, y - x)<br>        <span class="hljs-keyword">return</span> best<br><br><span class="hljs-comment"># Method 2: Union Find</span><br><span class="hljs-comment"># If we regard a consecutive sequence as a conected component (or a disjoint set), the problem becomes to get the size of largest connected component (or set).</span><br><br><span class="hljs-comment"># A node is a value of an element in nums in this case.</span><br><span class="hljs-comment"># Two nodes are connected if they are consecutive.</span><br><br><span class="hljs-comment"># O(N) time complexity is reqruired, so given nums[i], we should tell index of nums[i] - 1 if any, and nums[i] + 1 if any in O(1). That can be achieved using a map that maps value to index.</span><br><br><span class="hljs-comment"># Please note that for duplicate elements, we count only once.</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestConsecutive</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>):<br>            <span class="hljs-comment"># 如果父节点不等于本身，说明x不是祖先节点，通过路径压缩，x直接指向祖先节点，x的父节点变成祖先节点</span><br>            <span class="hljs-keyword">if</span> p[x] != x:<br>                p[x] = find(p[x])<br>            <span class="hljs-keyword">return</span> p[x]<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x,y</span>):<br>            p1,p2 = find(x), find(y)<br>            <span class="hljs-keyword">if</span> p1 != p2:<br>                p[p2] = p1<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        p = &#123;&#125;<br>        nums = <span class="hljs-built_in">set</span>(nums)<br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>            p[num] = num<br><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">if</span> num - <span class="hljs-number">1</span> <span class="hljs-keyword">in</span> nums:<br>                union(p[num],p[num-<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">if</span> num + <span class="hljs-number">1</span> <span class="hljs-keyword">in</span> nums:<br>                union(p[num],p[num+<span class="hljs-number">1</span>])<br><br>        d = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-built_in">print</span>(num, p[num],find(num))<br>            <span class="hljs-comment"># d[p[num]].append(num) is not correct. </span><br>            <span class="hljs-comment"># p[num] != find(num) during the ieteration process</span><br>            d[find(num)].append(num)<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>([<span class="hljs-built_in">len</span>(l) <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> d.values()])<br><br></code></pre></td></tr></table></figure>

<h3 id="Leetcode-125-Valid-Palindrome"><a href="#Leetcode-125-Valid-Palindrome" class="headerlink" title="Leetcode 125. Valid Palindrome"></a>Leetcode 125. Valid Palindrome</h3><ul>
<li>Judge if a character is alphanumeric characters x.isalnum()</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        l,r = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> l &lt; r:<br>            <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> s[l].isalnum():<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> s[r].isalnum():<br>                r -= <span class="hljs-number">1</span><br>            <br>            <span class="hljs-keyword">if</span> s[l].lower() != s[r].lower():<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <br>            l += <span class="hljs-number">1</span><br>            r -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>

<h3 id="Leetcode-15-3Sum"><a href="#Leetcode-15-3Sum" class="headerlink" title="Leetcode 15. 3Sum"></a>Leetcode 15. 3Sum</h3><ul>
<li>Apply 2Sum</li>
<li>Two pointers</li>
<li>注意重复数字问题 ***</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">nums,l,r,target,res</span>):<br>            last_pair = <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">while</span> l &lt; r:<br>                cursum = nums[l] + nums[r]<br>                <span class="hljs-keyword">if</span> cursum == target:<br>                    <span class="hljs-keyword">if</span> (nums[l], nums[r]) != last_pair:<br>                        res.append([-target,nums[l],nums[r]])<br>                    last_pair = (nums[l], nums[r])<br>                    l += <span class="hljs-number">1</span><br>                    r -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> cursum &lt; target:<br>                    l += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> cursum &gt; target:<br>                    r -= <span class="hljs-number">1</span><br>        <br>        results = []<br>        nums = <span class="hljs-built_in">sorted</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i-<span class="hljs-number">1</span>]: <span class="hljs-keyword">continue</span><br>            twoSum(nums,i+<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>,-nums[i],results)<br>        <span class="hljs-keyword">return</span> results<br></code></pre></td></tr></table></figure>

<h3 id="Leetcode-11-Container-With-Most-Water"><a href="#Leetcode-11-Container-With-Most-Water" class="headerlink" title="Leetcode 11. Container With Most Water"></a>Leetcode 11. Container With Most Water</h3><ul>
<li>Two pointers</li>
<li>每次移动矮左右中矮的柱子<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Idea / Proof:</span><br><br><span class="hljs-comment"># The widest container (using first and last line) is a good candidate, because of its width. Its water level is the height of the smaller one of first and last line.</span><br><span class="hljs-comment"># All other containers are less wide and thus would need a higher water level in order to hold more water.</span><br><span class="hljs-comment"># The smaller one of first and last line doesn&#x27;t support a higher water level and can thus be safely removed from further consideration.</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxArea</span>(<span class="hljs-params">self, height</span>):<br>        i, j = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(height) - <span class="hljs-number">1</span><br>        water = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; j:<br>            water = <span class="hljs-built_in">max</span>(water, (j - i) * <span class="hljs-built_in">min</span>(height[i], height[j]))<br>            <span class="hljs-keyword">if</span> height[i] &lt; height[j]:<br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                j -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> water<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="Leetcode-42-Trapping-Rain-Water"><a href="#Leetcode-42-Trapping-Rain-Water" class="headerlink" title="Leetcode 42. Trapping Rain Water"></a>Leetcode 42. Trapping Rain Water</h3><ul>
<li>Two pointers</li>
<li>每个index上的water volume &#x3D; min(left max, right max) - height[index]</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Method 1</span><br><span class="hljs-comment"># 每个位置上的盛水数目 = min(左侧最高，右侧最高) - 当前高度</span><br><span class="hljs-comment"># 从左到右扫描一边数组，获得每个位置往左这一段的最大值，再从右到左扫描一次获得每个位置向右的最大值。 然后最后再扫描一次数组，计算每个位置上的盛水数目。</span><br><span class="hljs-comment"># Time Complexity: O(n)</span><br><span class="hljs-comment"># Space Complexity: O(n)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    @param heights: a list of integers</span><br><span class="hljs-string">    @return: a integer</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">trapRainWater</span>(<span class="hljs-params">self, heights</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> heights:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            <br>        left_max = []<br>        curt_max = -sys.maxsize<br>        <span class="hljs-keyword">for</span> height <span class="hljs-keyword">in</span> heights:<br>            curt_max = <span class="hljs-built_in">max</span>(curt_max, height)<br>            left_max.append(curt_max)<br>            <br>        right_max = []<br>        curt_max = -sys.maxsize<br>        <span class="hljs-keyword">for</span> height <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(heights):<br>            curt_max = <span class="hljs-built_in">max</span>(curt_max, height)<br>            right_max.append(curt_max)<br>            <br>        right_max = right_max[::-<span class="hljs-number">1</span>]<br>            <br>        water = <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(heights)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            water += (<span class="hljs-built_in">min</span>(left_max[i], right_max[i]) - heights[i])<br>        <span class="hljs-keyword">return</span> water<br><br><br><span class="hljs-comment"># Method 2</span><br><span class="hljs-comment"># 双指针</span><br><span class="hljs-comment"># Time Complexity: O(n)</span><br><span class="hljs-comment"># Space Complexity: O(1)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">trap</span>(<span class="hljs-params">self, height: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment">#双指针</span><br>        <span class="hljs-comment">#左边的index可以知道exact left_max, 但是不确定exact right_max</span><br>        <span class="hljs-comment">#右边的index可以知道exact rigth_max, 但是不确定exact left_max</span><br>        <span class="hljs-comment">#通过比较当前的left_max and right_max, 可以得知每个index上的left_max和right_max的大小关系</span><br>        <span class="hljs-comment">#如果左边的index可以确定大小，left ++</span><br>        <span class="hljs-comment">#如果右边的index可以确定大小，right--</span><br>        <span class="hljs-comment"># 直到左右相遇</span><br>        l,r = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(height)-<span class="hljs-number">1</span><br>        left_max = height[l]<br>        right_max = height[r]<br>        volume = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> l &lt;= r:<br>            <span class="hljs-keyword">if</span> left_max &lt;= right_max:<br>                left_max = <span class="hljs-built_in">max</span>(left_max,height[l])<br>                volume += left_max - height[l]<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                right_max = <span class="hljs-built_in">max</span>(right_max, height[r])<br>                volume += right_max - height[r]<br>                r -= <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> volume<br><br><span class="hljs-comment"># Method 3</span><br><span class="hljs-comment"># 单调栈</span><br><span class="hljs-comment"># 用单调递减栈，当heightsi &gt; heights[stack-1], pop 栈直到栈顶大于当前数，压栈，并算盛水量</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    @param heights: a list of integers</span><br><span class="hljs-string">    @return: a integer</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">trapRainWater</span>(<span class="hljs-params">self, heights</span>):<br>      <span class="hljs-comment"># write your code here</span><br>      <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> heights:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>      res = <span class="hljs-number">0</span><br>      stack = [] <span class="hljs-comment"># decreasing</span><br>      <span class="hljs-keyword">for</span> i, n <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(heights):<br>        <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> heights[stack[-<span class="hljs-number">1</span>]] &lt; n:<br>            lower = heights[stack.pop()]<br>            <span class="hljs-keyword">if</span> stack:<br>              idx = stack[-<span class="hljs-number">1</span>]<br>              higher = <span class="hljs-built_in">min</span>(heights[idx], n)<br>              res += (higher - lower) * (i-idx-<span class="hljs-number">1</span>)<br>        stack.append(i)<br>        <br>      <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h1 id="Sliding-Window"><a href="#Sliding-Window" class="headerlink" title="Sliding Window"></a>Sliding Window</h1><h3 id="Leetcode-121-Best-Time-to-Buy-and-Sell-Stock"><a href="#Leetcode-121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Leetcode 121. Best Time to Buy and Sell Stock"></a>Leetcode 121. Best Time to Buy and Sell Stock</h3><ul>
<li><p>贪心法</p>
<ul>
<li>因为股票买卖必须是先买，后卖，所以在第N天的最大利润，就是0~N-1天中的最低值价值和第N天价格的差值。 只需要扫描一遍数组。扫描的同时，不断的更新最小值。然后用当前位置的价格减去最小值得到当天的收益。在把当天的收益和最大收益比较选最大的那一个。</li>
<li>Time Complexity: O(n)</li>
<li>Space Complexity: O(1)</li>
</ul>
</li>
<li><p>DP</p>
<ul>
<li>dp[i+1]: 在第i+1天sell –&gt; dp[i+1] &#x3D; max(dp[i] + q, q) where q &#x3D; nums[i+1] - nums[i]</li>
<li>有两种情况<ol>
<li>在第i+1天，lowest price不是nums[i]–&gt; dp[i+1] &#x3D; dp[i] + q</li>
<li>在第i+1天，lowest price就是nums[i]–&gt; dp[i+1] &#x3D; q</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Method1 贪心法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        minprice = sys.maxsize<br>        maximumProfit = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> prices:<br>            profit = p - minprice<br>            <span class="hljs-keyword">if</span> profit &gt; maximumProfit:<br>                maximumProfit = profit<br>            <br>            <span class="hljs-keyword">if</span> p &lt; minprice:<br>                minprice = p<br>        <br>        <span class="hljs-keyword">return</span> res<br><br><span class="hljs-comment"># Method2: DP</span><br><span class="hljs-comment"># dp[i+1] = nums[i+1] - lowest</span><br><span class="hljs-comment"># dp[i] = nums[i] - lowest</span><br><span class="hljs-comment"># q = nums[i+1] - nums[i]</span><br><span class="hljs-comment"># dp[i+1] = dp[i] + q</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(prices)<br>        dp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>):<br>            q = prices[i+<span class="hljs-number">1</span>] - prices[i]<br>            dp[i+<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i]+q,q)<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br></code></pre></td></tr></table></figure>


<h3 id="Leetcode-3-Longest-Substring-Without-Repeating-Characters"><a href="#Leetcode-3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Leetcode 3. Longest Substring Without Repeating Characters"></a>Leetcode 3. Longest Substring Without Repeating Characters</h3><ul>
<li>Slicing window (同向双指针)</li>
<li>对于每个index作为起点，计算最长无重复substring.</li>
<li>对于每个index，不断往后移右指针，一旦如果碰到重复元素，计算此时长度，更新全局最长substring. 然后开始下一轮。</li>
<li>注意visited需要释放出当前index元素，然后开始下一轮</li>
<li>Complexity:<ul>
<li>Time: O(n)</li>
</ul>
</li>
</ul>
<ul>
<li>Solution 1 For循环左指针，右指针驱动</li>
</ul>
<ol>
<li>遍历每一个左指针，找到右指针最右的边界</li>
<li>当出现重复字母，计算r-l的长度，更新全局变量</li>
<li>左指针往后移一位，同时release visited中的字母<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(s)<br>        visited = <span class="hljs-built_in">set</span>()<br>        longest = <span class="hljs-number">0</span><br>        r = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">while</span> r &lt; n <span class="hljs-keyword">and</span> s[r] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br>                <span class="hljs-comment"># !! Notice 右指针加入visited</span><br>                visited.add(s[r])<br>                r += <span class="hljs-number">1</span><br>            longest = <span class="hljs-built_in">max</span>(longest, r-l)<br>            visited.remove(s[l])<br>        <span class="hljs-keyword">return</span> longest<br></code></pre></td></tr></table></figure>
Solution 2 For循环右指针，左指针驱动<br>hashmap + 双指针</li>
<li>遍历每一个右指针指针，每移一次右指针更新当前全局最大值</li>
<li>当出现重复字母，移动左指针到上次出现这个字母的下一个位置如果这个位置大于当前左指针的位置，否则左指针位置不变</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution_dict</span>:  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, string</span>):<br>        lo, window_size, indices = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &#123;&#125;<br>        <span class="hljs-keyword">for</span> hi, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(string):<br>            <span class="hljs-keyword">if</span> c <span class="hljs-keyword">in</span> indices:<br>                lo = <span class="hljs-built_in">max</span>(lo, indices[c] + <span class="hljs-number">1</span>)<br>            window_size = <span class="hljs-built_in">max</span>(window_size, hi - lo + <span class="hljs-number">1</span>)<br>            indices[c] = hi    <br>        <span class="hljs-keyword">return</span> window_size<br></code></pre></td></tr></table></figure>




<h3 id="Leetcode-424-Longest-Repeating-Character-Replacement"><a href="#Leetcode-424-Longest-Repeating-Character-Replacement" class="headerlink" title="Leetcode 424. Longest Repeating Character Replacement"></a>Leetcode 424. Longest Repeating Character Replacement</h3><ul>
<li>双指针 + 哈希</li>
<li>Time complexity: O(n)</li>
<li>Space complexity: O(1)</li>
<li>For循环右指针。每次右指针向右移动一位，count更新并找到此时相同字母出现最高的次数 maximum_frequency。</li>
<li>如果 r - l + 1 - maximum_frequency &lt;&#x3D; k –&gt; 跟新result； else–&gt; 左指针向右移一位 l +&#x3D; 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">characterReplacement</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        l = <span class="hljs-number">0</span><br>        res = <span class="hljs-number">0</span><br>        cur_maxcount = <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(s)<br>        counter = defaultdict(<span class="hljs-built_in">int</span>)<br>        <br>        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            counter[s[r]] += <span class="hljs-number">1</span><br>            cur_maxcount = <span class="hljs-built_in">max</span>(cur_maxcount, counter[s[r]])<br>            <span class="hljs-keyword">if</span> r - l + <span class="hljs-number">1</span> - cur_maxcount &lt;= k:<br>                res = <span class="hljs-built_in">max</span>(res, r-l + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">else</span>:<br>                counter[s[l]] -= <span class="hljs-number">1</span><br>                l += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>


<h3 id="Leetcode-567-Permutation-in-String"><a href="#Leetcode-567-Permutation-in-String" class="headerlink" title="Leetcode 567. Permutation in String"></a>Leetcode 567. Permutation in String</h3><ul>
<li>固定长度滑动窗口模版</li>
<li>字母表哈希</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkInclusion</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        v1 = [<span class="hljs-number">0</span>] * <span class="hljs-number">26</span><br>        v2 = [<span class="hljs-number">0</span>] * <span class="hljs-number">26</span><br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s1:<br>            v1[<span class="hljs-built_in">ord</span>(c) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)] += <span class="hljs-number">1</span><br>        n1 = <span class="hljs-built_in">len</span>(s1)<br>        n2 = <span class="hljs-built_in">len</span>(s2)<br>        <span class="hljs-keyword">if</span> n2 &lt; n1:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n2):<br>            v2[<span class="hljs-built_in">ord</span>(s2[i]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> i &gt;= n1:<br>                v2[<span class="hljs-built_in">ord</span>(s2[i-n1]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> v1 == v2:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>


<h3 id="Leetcode-76-Minimum-Window-Substring"><a href="#Leetcode-76-Minimum-Window-Substring" class="headerlink" title="Leetcode 76. Minimum Window Substring"></a>Leetcode 76. Minimum Window Substring</h3><ul>
<li>二分<ul>
<li>满足条件的substring的长度是单调增</li>
<li>判断长度为k的substring是否可以包含所有的target -&gt; Time Complexity: O(n)</li>
<li>二分找到最小k -&gt; Time Complexity: O(log(n))</li>
<li>Total Time Complexity: nlog(n)</li>
</ul>
</li>
<li>sliding window<ul>
<li>Time Complexity: O(n)–&gt; 左右指针都只会向左移动一次</li>
<li>遍历右指针，直到满足包含所有的target，然后移动左指针，直到不满足包含所有target。记录最短substring</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Method1: Sliding Window</span><br><span class="hljs-comment"># step1: isequal() function: 判断此时的substring是否满足包含所有target的字母（hashmap)</span><br><span class="hljs-comment"># step2: For loop right pointer, until iseuqal() == True --&gt; Then move left point, until iseuqal() == False</span><br><span class="hljs-comment"># Find the minimum length of satisfied substring</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minWindow</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        target_ct = Counter(t)<br>        curr_ct = Counter()<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">isequal</span>():<br>            <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> target_ct:<br>                <span class="hljs-keyword">if</span> target_ct[key] &gt; curr_ct[key]:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <br>        l = <span class="hljs-number">0</span><br>        res = [<span class="hljs-number">0</span>,inf]<br>        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            curr_ct[s[r]] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isequal(): <br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">while</span> l &lt; r+<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> isequal():<br>                    <span class="hljs-keyword">if</span> r + <span class="hljs-number">1</span> - l &lt; res[<span class="hljs-number">1</span>] - res[<span class="hljs-number">0</span>]:<br>                        res = [l, r+<span class="hljs-number">1</span>]<br>                    curr_ct[s[l]] -= <span class="hljs-number">1</span><br>                    l += <span class="hljs-number">1</span><br>                    <br>        <br>        <span class="hljs-keyword">if</span> res == [<span class="hljs-number">0</span>,inf]: <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">return</span> s[res[<span class="hljs-number">0</span>]:res[<span class="hljs-number">1</span>]]<br><br><br><span class="hljs-comment">### Method2 Two pointers</span><br><span class="hljs-comment"># step1 isequal() --&gt; Check if a substring contains target</span><br><span class="hljs-comment"># step2 check(k) --&gt; Check if a substring with length k can contain target</span><br><span class="hljs-comment"># step3 Two points --&gt; Find the minimum k</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minWindow</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <br>        t_ct = Counter(t)<br>        n = <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">isequal</span>(<span class="hljs-params">ct1,ct2</span>):<br>            <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> ct1:<br>                <span class="hljs-keyword">if</span> ct1[key] &gt; ct2[key]:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">k</span>):<br>            ct2 = Counter()<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>                ct2[s[i]] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> isequal(t_ct,ct2):<br>                <span class="hljs-keyword">return</span> [<span class="hljs-number">0</span>,k]<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k,n):<br>                ct2[s[i-k]] -= <span class="hljs-number">1</span><br>                ct2[s[i]] += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> isequal(t_ct,ct2):<br>                    <span class="hljs-keyword">return</span> [i-k+<span class="hljs-number">1</span>, i+<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <br>        l,r = <span class="hljs-number">1</span>, n+<span class="hljs-number">1</span><br>        ans = []<br>        <span class="hljs-keyword">while</span> l &lt; r:<br>            mid = (l+r)//<span class="hljs-number">2</span><br>            tmp = check(mid)<br>            <span class="hljs-keyword">if</span> tmp:<br>                r = mid<br>                ans = tmp<br>            <span class="hljs-keyword">else</span>:<br>                l = mid + <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">if</span> ans == []:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> s[ans[<span class="hljs-number">0</span>]:ans[<span class="hljs-number">1</span>]]          <br></code></pre></td></tr></table></figure>


<h4 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239. Sliding Window Maximum"></a>239. Sliding Window Maximum</h4><ul>
<li>单调双端队列<ol>
<li>维护单调递减队列，如果队尾数&lt;此时数，pop队尾数，直到满足递减性</li>
<li>把当前下标放入队列</li>
<li>如果此时队列里数长度&#x3D;&#x3D; k+1，说明队首的最大值已经滑出的窗口，需要pop out队首最大值</li>
<li>如果此时index&gt;&#x3D; k-1,已经遍历足够窗口数，就可以开始输出窗口最大值–&gt; 队首元素</li>
</ol>
</li>
<li>队尾的数先入队，还比此时的数下表要小，那肯定不会是此时以及以后的窗口的最大值了</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSlidingWindow</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-comment"># 1. 维护单调递减队列，如果队尾数&lt;此时数，pop队尾数，直到满足递减性</span><br>        <span class="hljs-comment"># 2. 把当前下标放入队列</span><br>        <span class="hljs-comment"># 3. 如果此时队列里数长度== k+1，说明队首的最大值已经滑出的窗口，需要pop out队首最大值</span><br>        <span class="hljs-comment"># 4. 如果此时index&gt;= k-1,已经遍历足够窗口数，就可以开始输出窗口最大值--&gt; 队首元素 </span><br>        queue = deque()<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        res = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">while</span> queue <span class="hljs-keyword">and</span> nums[queue[-<span class="hljs-number">1</span>]] &lt; nums[i]:<br>                queue.pop()<br>            queue.append(i)<br>            <br>            <span class="hljs-keyword">if</span> i - queue[<span class="hljs-number">0</span>] == k:<br>                queue.popleft()<br>            <br>            <span class="hljs-keyword">if</span> i &gt;= k-<span class="hljs-number">1</span>:<br>                res.append(nums[queue[<span class="hljs-number">0</span>]])<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><h4 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155. Min Stack"></a>155. Min Stack</h4><ul>
<li><p>要求O(1)时间内完成所有操作，压入栈弹和出栈顶元素并返回本来就是O(1)没有问题，要返回栈中元素最小值也是O(1)就需要一个辅助栈。</p>
</li>
<li><p>在压入新元素时，如果辅助栈为空或者辅助栈顶元素大于新元素，那么新元素就是目前最小值，压入新元素；如果辅助栈顶元素小于新元素，那么再次压入栈顶元素。</p>
</li>
<li><p>在弹出元素时，辅助栈跟着一起弹出栈顶元素。</p>
</li>
<li><p>这样就满足了辅助栈内存储的最小值与存储数据的栈同步，查询最小值的操作是O(1)的。</p>
</li>
<li><p>create一个辅助min_stack，每次记录下当前的最小值</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.stack = []<br>        self.min_stack = []<br>        <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.stack.append(val)<br>        self.min_stack.append(<span class="hljs-built_in">min</span>(val,self.min_stack[-<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> self.min_stack <span class="hljs-keyword">else</span> val))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.stack.pop()<br>        self.min_stack.pop()<br>        <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">top</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> self.stack[-<span class="hljs-number">1</span>]<br>        <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getMin</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> self.min_stack[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>

<h4 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22.Generate Parentheses"></a>22.Generate Parentheses</h4><ul>
<li>DFS&#x2F;Backtracking</li>
<li>这里回溯不需要pop,因为cur这个parameter handel了回溯这个过程<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs livescript">res = []<br>helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">3</span>, r = <span class="hljs-number">3</span>,<span class="hljs-string">&#x27;&#x27;</span>,res)</span> --&gt;</span><br>l &gt; <span class="hljs-number">0</span> --&gt; helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">2</span>,r = <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;(&#x27;</span>, res)</span> --&gt;</span><br>l &gt; <span class="hljs-number">0</span> --&gt; helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">1</span>,r = <span class="hljs-number">3</span>,<span class="hljs-string">&#x27;((&#x27;</span>, res)</span> --&gt;</span> <span class="hljs-keyword">if</span> l&gt;<span class="hljs-number">0</span> END --&gt; Now go <span class="hljs-keyword">to</span> <span class="hljs-keyword">if</span> r &gt; <span class="hljs-number">0</span> --&gt; helper(l = <span class="hljs-number">1</span>,r = <span class="hljs-number">2</span>,<span class="hljs-string">&#x27;(()&#x27;</span>, res)<br>l &gt; <span class="hljs-number">0</span> --&gt; helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">0</span>, r = <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;(((&#x27;</span>, res)</span> --&gt;</span> END<br>r &gt; <span class="hljs-number">0</span> --&gt; helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">0</span>, r = <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;((()&#x27;</span>, res)</span> --&gt;</span> END<br>r &gt; <span class="hljs-number">0</span> --&gt; helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;((())&#x27;</span>, res)</span> --&gt;</span> END<br>r &gt; <span class="hljs-number">0</span> --&gt; helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;((()))&#x27;</span>, res)</span> --&gt;</span> END<br>l == <span class="hljs-number">0</span> &amp; r == <span class="hljs-number">0</span> --&gt; res.append(<span class="hljs-string">&#x27;((()))&#x27;</span>) <br>=================================================================================<br>l &gt; <span class="hljs-number">0</span> --&gt; helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">1</span>,r = <span class="hljs-number">2</span>,<span class="hljs-string">&#x27;(()&#x27;</span>, res)</span> --&gt;</span> If l&gt;<span class="hljs-number">0</span> END --&gt; Now go <span class="hljs-keyword">to</span> <span class="hljs-keyword">if</span> r &gt; <span class="hljs-number">0</span> --&gt; helper(l = <span class="hljs-number">1</span>,r = <span class="hljs-number">1</span>,<span class="hljs-string">&#x27;(())&#x27;</span>, res)<br>l &gt; <span class="hljs-number">0</span> --&gt; helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">0</span>,r = <span class="hljs-number">2</span>,<span class="hljs-string">&#x27;(()(&#x27;</span>, res)</span> --&gt;</span> END<br>l &gt; <span class="hljs-number">0</span> --&gt; helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">0</span>,r = <span class="hljs-number">1</span>,<span class="hljs-string">&#x27;(()()&#x27;</span>, res)</span> --&gt;</span> END<br>l &gt; <span class="hljs-number">0</span> --&gt; helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">0</span>,r = <span class="hljs-number">0</span>,<span class="hljs-string">&#x27;(()())&#x27;</span>, res)</span> --&gt;</span> END<br>l == <span class="hljs-number">0</span> &amp; r == <span class="hljs-number">0</span> --&gt; res.append(<span class="hljs-string">&#x27;(()())&#x27;</span>)<br>=================================================================================<br>l &gt; <span class="hljs-number">0</span> --&gt; helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">1</span>,r = <span class="hljs-number">1</span>,<span class="hljs-string">&#x27;(())&#x27;</span>, res)</span> --&gt;</span> If l&gt;<span class="hljs-number">0</span> END --&gt; Now go <span class="hljs-keyword">to</span> <span class="hljs-keyword">if</span> r &gt; <span class="hljs-number">0</span> --&gt; helper(l = <span class="hljs-number">1</span>,r = <span class="hljs-number">0</span>,<span class="hljs-string">&#x27;(()))&#x27;</span>, res)<br>l &gt; <span class="hljs-number">0</span> --&gt; helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">0</span>,r = <span class="hljs-number">1</span>,<span class="hljs-string">&#x27;(())(&#x27;</span>, res)</span> --&gt;</span> END<br>l &gt; <span class="hljs-number">0</span> --&gt; helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">0</span>,r = <span class="hljs-number">0</span>,<span class="hljs-string">&#x27;(())()&#x27;</span>, res)</span> --&gt;</span> END<br>l == <span class="hljs-number">0</span> &amp; r == <span class="hljs-number">0</span> --&gt; res.append(<span class="hljs-string">&#x27;(())()&#x27;</span>) <br>=================================================================================<br>helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">1</span>,r = <span class="hljs-number">0</span>,<span class="hljs-string">&#x27;(()))&#x27;</span>, res)</span> --&gt;</span> r &lt; l Not qualified --&gt; Return END<br>helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">1</span>,r = <span class="hljs-number">1</span>,<span class="hljs-string">&#x27;(())&#x27;</span>, res)</span> --&gt;</span> END<br>helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">1</span>,r = <span class="hljs-number">2</span>,<span class="hljs-string">&#x27;(())&#x27;</span>, res)</span> --&gt;</span> END<br>helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">1</span>,r = <span class="hljs-number">3</span>,<span class="hljs-string">&#x27;(())&#x27;</span>, res)</span> --&gt;</span> END<br>=================================================================================<br>l &gt; <span class="hljs-number">0</span> --&gt; helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">2</span>,r = <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;()&#x27;</span>, res)</span> --&gt;</span><br>l &gt; <span class="hljs-number">0</span> --&gt; helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">1</span>,r = <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;()(&#x27;</span>, res)</span> --&gt;</span> If l&gt;<span class="hljs-number">0</span> END --&gt; helper(l = <span class="hljs-number">1</span>,r = <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;()()&#x27;</span>, res)<br>l &gt; <span class="hljs-number">0</span> --&gt; helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">0</span>,r = <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;()((&#x27;</span>, res)</span> --&gt;</span> END<br>l &gt; <span class="hljs-number">0</span> --&gt; helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">0</span>,r = <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;()(()&#x27;</span>, res)</span> --&gt;</span> END<br>l &gt; <span class="hljs-number">0</span> --&gt; helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">0</span>,r = <span class="hljs-number">0</span> <span class="hljs-string">&#x27;()(())&#x27;</span>, res)</span> --&gt;</span> END<br>l == <span class="hljs-number">0</span> &amp; r == <span class="hljs-number">0</span> --&gt; res.append(<span class="hljs-string">&#x27;()(())&#x27;</span>) <br>=================================================================================<br>helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">1</span>,r = <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;()()&#x27;</span>, res)</span> --&gt;</span> If l&gt;<span class="hljs-number">0</span> END --&gt; helper(l = <span class="hljs-number">1</span>,r = <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;()())&#x27;</span>, res)<br>helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">0</span>,r = <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;()()(&#x27;</span>, res)</span> --&gt;</span> END<br>helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">0</span>,r = <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;()()()&#x27;</span>, res)</span> --&gt;</span> END<br>l == <span class="hljs-number">0</span> &amp; r == <span class="hljs-number">0</span> --&gt; res.append(<span class="hljs-string">&#x27;()()()&#x27;</span>) <br>=================================================================================<br>helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">1</span>,r = <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;()())&#x27;</span>, res)</span> --&gt;</span> r &lt; l Not qualified --&gt; Return END<br>helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">1</span>,r = <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;()()&#x27;</span>, res)</span> --&gt;</span> END<br>helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">1</span>,r = <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;()()&#x27;</span>, res)</span> --&gt;</span> END<br>l &gt; <span class="hljs-number">0</span> --&gt; helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">2</span>,r = <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;()&#x27;</span>, res)</span> --&gt;</span> helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">2</span>,r = <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;()&#x27;</span>, res)</span> --&gt;</span> r &lt; l Not qualified --&gt; Return END<br>helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">2</span>,r = <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;()&#x27;</span>, res)</span> --&gt;</span> END<br>helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">2</span>,r = <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;()&#x27;</span>, res)</span> --&gt;</span> END<br>helper<span class="hljs-function"><span class="hljs-params">(l = <span class="hljs-number">3</span>,r = <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;()&#x27;</span>, res)</span> --&gt;</span> END<br><br>ENDING<br></code></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generateParenthesis</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">l,r,cur,res</span>):<br>            <span class="hljs-keyword">if</span> r &lt; l:<br>                <span class="hljs-keyword">return</span><br>            <br>            <span class="hljs-keyword">if</span> l == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> r == <span class="hljs-number">0</span>:<br>                res.append(cur)<br>            <br>            <span class="hljs-keyword">if</span> l &gt; <span class="hljs-number">0</span>:<br>                dfs(l-<span class="hljs-number">1</span>,r,cur+<span class="hljs-string">&#x27;(&#x27;</span>,res)<br>            <span class="hljs-keyword">if</span> r &gt; <span class="hljs-number">0</span>:<br>                dfs(l,r-<span class="hljs-number">1</span>,cur+<span class="hljs-string">&#x27;)&#x27;</span>,res)<br><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> []<br>        res = []<br>        dfs(n,n,<span class="hljs-string">&#x27;&#x27;</span>,res)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>


<h4 id="739-Daily-Temperatures"><a href="#739-Daily-Temperatures" class="headerlink" title="739. Daily Temperatures"></a>739. Daily Temperatures</h4><ul>
<li>Monotonic Stack</li>
<li>Decreasing monotonic stack<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Method 1 </span><br><span class="hljs-comment"># 从前往后遍历，维护一个单调递减栈 stack</span><br><span class="hljs-comment"># 比较当前值与栈顶值的大小，while 如果当前值 &gt; 栈顶值，则找到了栈顶的next warmer day,记录下答案。并把栈顶pop!!</span><br><span class="hljs-comment"># 直到当前值 &lt; 栈顶值，把当前值的下标放入栈里</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dailyTemperatures</span>(<span class="hljs-params">self, temp: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(temp)<br>        stack = []<br>        ans = [<span class="hljs-number">0</span>] * n<br>        <span class="hljs-keyword">for</span> idx, t <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(temp):<br>            <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> t &gt; temp[stack[-<span class="hljs-number">1</span>]]:<br>                ans[stack[-<span class="hljs-number">1</span>]] = idx - stack[-<span class="hljs-number">1</span>]<br>                stack.pop()<br>            <br>            stack.append(idx)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="853-Car-Fleet"><a href="#853-Car-Fleet" class="headerlink" title="853. Car Fleet"></a>853. Car Fleet</h4><ul>
<li>按照position和speed排序，找到位置最前面的车</li>
<li>如果后面的车无障碍下到达终点所需时间 &lt;&#x3D; 前面的车，则后面的车和前面的车组成车队，后面的车消失</li>
<li>如果后面的车无障碍下到达终点所需时间 &gt; 前面的车, 则后面的车自成一个车队的领头</li>
<li>注意由于后面的车不能超过前面的车，所有可以按照位置排序，看后面的车是否可以追赶上前面的车！！但是不能超过前面的车！！</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/car-fleet/discuss/255589/Python-Code-with-Explanations-and-Visualization-Beats-95">https://leetcode.com/problems/car-fleet/discuss/255589/Python-Code-with-Explanations-and-Visualization-Beats-95</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Method1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">carFleet</span>(<span class="hljs-params">self, target: <span class="hljs-built_in">int</span>, pos: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], speed: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        time = [<span class="hljs-built_in">float</span>(target - p) / s <span class="hljs-keyword">for</span> p, s <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">zip</span>(pos, speed))]<br>        res = cur = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> time[::-<span class="hljs-number">1</span>]:<br>            <span class="hljs-keyword">if</span> t &gt; cur:<br>                res += <span class="hljs-number">1</span><br>                cur = t<br>        <span class="hljs-keyword">return</span> res<br><br><span class="hljs-comment"># Method2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">carFleet</span>(<span class="hljs-params">self, target: <span class="hljs-built_in">int</span>, pos: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], speed: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        stack = []<br>        res = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> p,s <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">zip</span>(pos, speed))[::-<span class="hljs-number">1</span>]:<br>            t = (target - p)/s<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> stack:<br>                stack.append(t)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> t &gt; stack[-<span class="hljs-number">1</span>]:<br>                    res += <span class="hljs-number">1</span><br>                    stack.append(t)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h4 id="84-Largest-Rectangle-in-Histogram"><a href="#84-Largest-Rectangle-in-Histogram" class="headerlink" title="84. Largest Rectangle in Histogram"></a>84. Largest Rectangle in Histogram</h4><ul>
<li>单调栈</li>
<li>想法 for given bar i with value h, how to find the biggest rectangle, which is ending with this bar ？</li>
<li>维护一个严格单调递增栈（当x因为≥current被pop出来，想找的是左边第一个小于x的下标l，和右边第一个小于x的下标r（就是current的下标）,所以用单调递增栈。在(l,r)这段区间内的下标对应的number都 ≥ x,所以这段区间内矩形的面积是用x作为高，(r-l-1)作为宽度, 面积S &#x3D; x * (r-l-1). 不断遍历每个bar, 打擂台得到全局最大值</li>
<li>注意需要在末尾加一个0保证遍历到每一个number</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Time Complexity: O(n)</span><br><span class="hljs-comment"># Space Complexity: O(n)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">largestRectangleArea</span>(<span class="hljs-params">self, heights</span>):<br>        stack, ans = [], <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i, h <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(heights + [<span class="hljs-number">0</span>]):<br>            <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> heights[stack[-<span class="hljs-number">1</span>]] &gt;= h:<br>                H = heights[stack.pop()]<br>                W = i <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> stack <span class="hljs-keyword">else</span> i-stack[-<span class="hljs-number">1</span>]-<span class="hljs-number">1</span><br>                ans = <span class="hljs-built_in">max</span>(ans, H*W)<br>            stack.append(i)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure>

<h1 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h1><h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><h3 id="整数二分法模版"><a href="#整数二分法模版" class="headerlink" title="整数二分法模版"></a>整数二分法模版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 第1种 mid = (l+r)//2</span><br><span class="hljs-comment"># 区间[l,r]被划分成[l,mid]和[mid+1,r]时使用</span><br><span class="hljs-keyword">while</span> l &lt; r:<br>    mid = (l+r)//<span class="hljs-number">2</span><br>    <span class="hljs-comment"># 满足check函数说明mid值太大了，需要往左走</span><br>    <span class="hljs-keyword">if</span> check(mid):<br>        r = mid<br>    <span class="hljs-keyword">else</span>:<br>        l = mid + <span class="hljs-number">1</span><br><br><span class="hljs-keyword">if</span> check(l): <span class="hljs-keyword">return</span> l<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br><span class="hljs-comment"># 第2种 mid = (l+r+1)//2</span><br><span class="hljs-comment"># 区间[l,r]被划分成[l,mid-1]和[mid,r]时使用</span><br><span class="hljs-keyword">while</span> l &lt; r:<br>    mid = (l+r+<span class="hljs-number">1</span>)//<span class="hljs-number">2</span><br>    <span class="hljs-comment"># 满足check函数说明mid值太小了，需要往右走</span><br>    <span class="hljs-keyword">if</span> check(mid):<br>        l = mid<br>    <span class="hljs-keyword">else</span>:<br>        r = mid - <span class="hljs-number">1</span><br><br><span class="hljs-keyword">if</span> check(l): <span class="hljs-keyword">return</span> l<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h3 id="九章算法二分模版"><a href="#九章算法二分模版" class="headerlink" title="九章算法二分模版"></a>九章算法二分模版</h3><p>二分查找的模版，找第一次出现的位置。 注意可能出现多次，所以当找到这个数字的时候不能直接结束，而要将end移动到mid处。 直到最后缩小到只有一个或两个数字时，优先判断start，再判断end。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums: <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        l,r = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> l + <span class="hljs-number">1</span> &lt; r:<br>            mid = (l+r) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> nums[mid] &lt; target:<br>                l = mid<br>            <span class="hljs-keyword">elif</span> nums[mid] == target:<br>                r = mid<br>            <span class="hljs-keyword">else</span>:<br>                r = mid<br>        <br>        <span class="hljs-keyword">if</span> nums[l] == target:<br>            <span class="hljs-keyword">return</span> l<br>        <span class="hljs-keyword">elif</span> nums[r] == target:<br>            <span class="hljs-keyword">return</span> r<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h3 id="import-bisect"><a href="#import-bisect" class="headerlink" title="import bisect"></a>import bisect</h3><ul>
<li><p>Notice position parameters is [Beg,end) 前开后闭</p>
<h4 id="Time-Complexity-O-log-n"><a href="#Time-Complexity-O-log-n" class="headerlink" title="Time Complexity O(log(n))"></a>Time Complexity O(log(n))</h4></li>
<li><p>bisect.bisect_left(list, num, beg, end): </p>
</li>
<li><p>This function returns the position in the sorted list, where the number passed in argument can be placed so as to maintain the resultant list in sorted order. If the element is already present in the list, the left most position where element has to be inserted is returned. </p>
</li>
<li><p>bisect.bisect_right(list, num, beg, end)</p>
</li>
<li><p>This function returns the position in the sorted list, where the number passed in argument can be placed so as to maintain the resultant list in sorted order. If the element is already present in the list, the right most position where element has to be inserted is returned.</p>
</li>
</ul>
<h4 id="Time-Complexity-O-n-gt-Inserting-an-element-in-sorted-array-requires-traversal"><a href="#Time-Complexity-O-n-gt-Inserting-an-element-in-sorted-array-requires-traversal" class="headerlink" title="Time Complexity O(n) -&gt; Inserting an element in sorted array requires traversal"></a>Time Complexity O(n) -&gt; Inserting an element in sorted array requires traversal</h4><ul>
<li><p>insort_left(list, num, beg, end)</p>
</li>
<li><p>This function returns the sorted list after inserting number in appropriate position, if the element is already present in the list, the element is inserted at the leftmost possible position. </p>
</li>
<li><p>insort_left(list, num, beg, end)</p>
</li>
<li><p>This function returns the sorted list after inserting number in appropriate position, if the element is already present in the list, the element is inserted at the rightmost possible position.</p>
</li>
</ul>
<h4 id="153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="153. Find Minimum in Rotated Sorted Array"></a>153. Find Minimum in Rotated Sorted Array</h4><ul>
<li><p>Binary Search</p>
</li>
<li><p>edge case</p>
<ul>
<li><ol>
<li>if len(nums) &#x3D;&#x3D; 1:  return nums[0]</li>
</ol>
</li>
<li><ol start="2">
<li>if nums[0] &lt; nums[n-1]: return nums[0] –&gt; Not rotate</li>
</ol>
</li>
</ul>
</li>
<li><p>Binary search, left &#x3D; 0, right &#x3D; n-1</p>
<ul>
<li>mid &#x3D; (l+r)&#x2F;&#x2F;2</li>
<li>if nums[mid-1] &gt; nums[mid]: return mid –&gt; rotate的山峰点</li>
<li>if nums[mid] &gt; nums[right], then the minimum number is on the right side. Search right side. l &#x3D; mid + 1</li>
<li>else: nums[mid] &lt;&#x3D; nums[right] then search left side. r &#x3D; mid</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMin</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># edge case</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>        <br>        l,r = <span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> l + <span class="hljs-number">1</span> &lt; r:<br>            mid = (l+r)//<span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> nums[mid-<span class="hljs-number">1</span>] &gt; nums[mid]:<br>                <span class="hljs-keyword">return</span> nums[mid]<br>            <span class="hljs-keyword">if</span> nums[mid] &gt; nums[r]:<br>                l = mid + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                r = mid<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(nums[l], nums[r])<br></code></pre></td></tr></table></figure>


<h4 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33. Search in Rotated Sorted Array"></a>33. Search in Rotated Sorted Array</h4><ul>
<li>Method1 用两次二分<ul>
<li>第一次二分找到最小值的index</li>
<li>通过最小值找到target在左边还是右边</li>
<li>第二次二分找到target的下标</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># first find the index of the mininmum number</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_minimum_index</span>(<span class="hljs-params">nums</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            <br>            l,r = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> l +<span class="hljs-number">1</span> &lt; r:<br>                mid = (l+r)//<span class="hljs-number">2</span><br>                <span class="hljs-keyword">if</span> nums[mid-<span class="hljs-number">1</span>] &gt; nums[mid]:<br>                    <span class="hljs-keyword">return</span> mid<br>                <span class="hljs-keyword">if</span> nums[mid] &gt; nums[r]:<br>                    l = mid + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    r = mid<br>            <br>            <span class="hljs-keyword">if</span> nums[l] &lt; nums[r]:<br>                <span class="hljs-keyword">return</span> l<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> r<br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">binary_search</span>(<span class="hljs-params">nums,target,l,r</span>):<br>            <span class="hljs-keyword">while</span> l+<span class="hljs-number">1</span> &lt; r:<br>                mid = (l+r)//<span class="hljs-number">2</span><br>                <span class="hljs-keyword">if</span> nums[mid] &lt; target:<br>                    l = mid<br>                <span class="hljs-keyword">else</span>:<br>                    r= mid<br><br>            <span class="hljs-keyword">if</span> nums[l] == target:<br>                <span class="hljs-keyword">return</span> l<br>            <span class="hljs-keyword">elif</span> nums[r] == target:<br>                <span class="hljs-keyword">return</span> r<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        <br>        minimum_index = find_minimum_index(nums)<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> nums[minimum_index] &lt;= target &lt;= nums[-<span class="hljs-number">1</span>]:<br>            <span class="hljs-keyword">return</span> binary_search(nums,target,minimum_index,n-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> binary_search(nums,target,<span class="hljs-number">0</span>,minimum_index-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>



<ul>
<li>Method2 用一次二分<ul>
<li>二分搜索时每次都是把数组分成两部分，先判段哪一部分是有序的</li>
<li>如果target在有序的那一部分，那么继续二分</li>
<li>如果在无序的那一部分，重复第一步</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 一次二分</span><br>        <span class="hljs-comment"># 1. 把数组分成两个部分，判断哪一部分是有序的</span><br>        <span class="hljs-comment"># 2. 如果target在有序的那一部分，就用origin二分继续chazhao</span><br>        <span class="hljs-comment"># 3. 如果target不在有序的那一部分，就重复第一步，再把数组分成两个部分</span><br>        l,r = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">while</span> l + <span class="hljs-number">1</span> &lt; r:<br>            mid = (l+r) // <span class="hljs-number">2</span><br>            <span class="hljs-comment"># （0 - mid）这一部分有序</span><br>            <span class="hljs-keyword">if</span> nums[mid] &gt; nums[<span class="hljs-number">0</span>]:<br>                <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] &lt;= target &lt;= nums[mid]:<br>                    r = mid<br>                <span class="hljs-keyword">else</span>:<br>                    l = mid<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># (mid, end)这一部分有序</span><br>                <span class="hljs-keyword">if</span> nums[mid] &lt;= target &lt;= nums[n-<span class="hljs-number">1</span>]:<br>                    l = mid<br>                <span class="hljs-keyword">else</span>:<br>                    r = mid<br>        <span class="hljs-keyword">if</span> nums[l] == target:<br>            <span class="hljs-keyword">return</span> l<br>        <span class="hljs-keyword">elif</span> nums[r] == target:<br>            <span class="hljs-keyword">return</span> r<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>


<h4 id="Leetcode-4-Median-of-Two-Sorted-Arrays"><a href="#Leetcode-4-Median-of-Two-Sorted-Arrays" class="headerlink" title="Leetcode 4. Median of Two Sorted Arrays"></a>Leetcode 4. Median of Two Sorted Arrays</h4><p>Method 1. 归并</p>
<ul>
<li><p>解题思路</p>
</li>
<li><p>最简单的思路是将两个数组合并，然后返回新数组的中位数。两个有序数组的合并也是经典归并排序算法的一步，我们可以新开一个数组，保存合并后的结果。<br>但是我们这样会做额外的工作，因为我们不必保存整个新数组，只需要知道新数组的中位数即可。</p>
</li>
<li><p>因此，更简便的方法是，使用双指针分别对两个数组遍历，比较两个指针下的元素大小，每次移动更小的指针，通过移动次数确定中位数的位置。</p>
</li>
<li><p>算法流程</p>
</li>
<li><p>令指针p1和p2分别指向两个数组，初始指向位置0。我们需要遍历(m + n)&#x2F;2 + 1次，每次比较两个位置的元素，在第k次比较时，较小的那个值就是两个数组中第k + 1小的数。<br>如果一个指针已经走到了数组末尾，那么移动另一个指针，否则每次将指向较小数的指针后移，直到遍历到中位数。</p>
</li>
<li><p>为了将奇偶情况合并，在代码中用了left和right保存中间值，如果是奇数直接返回right，如果是偶数就返回(left + right) &#x2F; 2。</p>
</li>
<li><p>复杂度分析</p>
</li>
<li><p>时间复杂度：O(m+n)，m和n分别是两个数组的长度。双指针遍历两个数组，指针移动次数是0(m+n)级。</p>
</li>
<li><p>空间复杂度：O(1)</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">float</span>:<br>        p1,p2 = <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>        left, right = -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span><br>        n1,n2 = <span class="hljs-built_in">len</span>(nums1), <span class="hljs-built_in">len</span>(nums2)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((n1+n2)//<span class="hljs-number">2</span> + <span class="hljs-number">1</span>):<br>            left = right<br>            <span class="hljs-keyword">if</span> p1 &gt;= n1 <span class="hljs-keyword">or</span> (p2 &lt;n2 <span class="hljs-keyword">and</span> nums1[p1] &gt; nums2[p2]):<br>                right = nums2[p2]<br>                p2 += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                right = nums1[p1]<br>                p1 += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">if</span> (n1+n2)%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> right<br>        <span class="hljs-keyword">return</span> (left+right)/<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>Method 2. 二分</p>
<ul>
<li>findKth: 找到在A[index_a:]和B[index_b:]中第k小的数</li>
<li>定义指针i和j，分别指向A和B，使得A[start1:i]和B[start2:j]的长度分别为k &#x2F;&#x2F; 2，通过比较A[i]和B[j]的大小，我们就可以确定排除哪段元素。<br>如果A[i] &gt; B[j]，说明B[start2:j]不可能为第k小元素。我们对A[start1:end1]和B[j + 1:end2]继续送入getKth进行递归，<br>k应该更新为k - (j - start2 + 1)。 * 反之，说明A[start1:i]不可能为第k小元素。我们对A[i + 1:end1]和B[start2:end2]继续送入getKth进行递归，<br>k应该更新为k - (i - start1 + 1)。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">float</span>:<br>        n = <span class="hljs-built_in">len</span>(nums1) + <span class="hljs-built_in">len</span>(nums2)<br>        <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> self.findKth(nums1,<span class="hljs-number">0</span>, nums2,<span class="hljs-number">0</span>,n//<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> (self.findKth(nums1,<span class="hljs-number">0</span>, nums2,<span class="hljs-number">0</span>,n//<span class="hljs-number">2</span>) + self.findKth(nums1,<span class="hljs-number">0</span>, nums2,<span class="hljs-number">0</span>,n//<span class="hljs-number">2</span>+<span class="hljs-number">1</span>))/<span class="hljs-number">2</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findKth</span>(<span class="hljs-params">self,A,index_a, B, index_b, k</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(A) == index_a:<br>            <span class="hljs-keyword">return</span> B[index_b+k-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(B) == index_b:<br>            <span class="hljs-keyword">return</span> A[index_a+k-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(A[index_a], B[index_b])<br>        <br>        a = A[index_a + k//<span class="hljs-number">2</span> -<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> index_a + k//<span class="hljs-number">2</span> &lt;= <span class="hljs-built_in">len</span>(A) <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>        b = B[index_b + k//<span class="hljs-number">2</span> -<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> index_b + k //<span class="hljs-number">2</span> &lt;= <span class="hljs-built_in">len</span>(B) <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>        <br>        <span class="hljs-keyword">if</span> b <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> (a != <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> a &lt; b):<br>            <span class="hljs-keyword">return</span> self.findKth(A,index_a + k//<span class="hljs-number">2</span>,B, index_b, k - k//<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> self.findKth(A,index_a, B, index_b + k//<span class="hljs-number">2</span>, k-k//<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>



<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><h2 id="Tree-Traversal"><a href="#Tree-Traversal" class="headerlink" title="Tree Traversal"></a>Tree Traversal</h2><ol>
<li>Inorder Traversal<ul>
<li>Left, Root, Right</li>
</ul>
</li>
<li>Preorder Traversal<ul>
<li>Root, Left, Right</li>
</ul>
</li>
<li>Postorder Traversal<ul>
<li>Left, Right, Root</li>
</ul>
</li>
</ol>
<h4 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a>94. Binary Tree Inorder Traversal</h4><ol>
<li><p>Method1 Recursion</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.ans = []<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-comment"># Inorder -&gt; left, root, right</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> []<br>        self.inorderTraversal(root.left)<br>        self.ans.append(root.val)<br>        self.inorderTraversal(root.right)<br>        <span class="hljs-keyword">return</span> self.ans<br></code></pre></td></tr></table></figure>
</li>
<li><p>Method2 Iteration<br>总的来讲，中序遍历和前序遍历相比，难点就在于，左-中-右 顺序中‘中’的处理。不止要保存‘中’节点的信息，而且还要保存是否已经访问‘中’节点的左节点。<br>其实对于一个非空节点，可能出现的情况有以下几种： </p>
</li>
<li><p>有左节点：这种情况继续分两种情况： </p>
<ul>
<li><ol>
<li>左节点没有被访问，那么应该继续向左</li>
</ol>
</li>
<li><ol start="2">
<li>左节点已经被访问，这种情况相当于2‘ 没有左节点</li>
</ol>
</li>
</ul>
</li>
<li><p>没有左节点：这个时候首先要print 这个节点，然后看右节点</p>
<ul>
<li><ol>
<li>有右节点：那么向右节点走，这个时候注意，这个有右节点的节点，已经被printed了</li>
</ol>
</li>
<li><ol start="2">
<li>没有右节点：那么返回这个节点的先驱节点（进入这个节点的上一个节点）</li>
</ol>
</li>
</ul>
</li>
</ol>
<p><em><strong>Method2</strong></em> (本人比较喜欢这个解法)仔细想一下，只有第一种方法改过来时最方便的。 需要的改动仅仅调换一下节点访问的次序.<br>先序是先访问，再入栈； 而中序则是先入栈，弹栈后再访问</p>
<p>解法的本质，其实是利用None的次数来标记父节点。<br>第一次向stack填入None的时候，都代表进入情况2（没有左节点了），这个时候pop 掉stack 并print，进入这个被print 节点的右子树，<br>然后第二次出现None的时候，是情况2.2（右子树也空了），这个时候pop出来的就是真正的先驱节点。那个已经被printed的先驱节点，<br>在第一次出现None的时候已经被pop掉了   </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> []<br><br>        stack = []<br>        inorder = []<br>        node = root<br>        <span class="hljs-keyword">while</span> node <span class="hljs-keyword">or</span> stack:<br>            <span class="hljs-comment"># curr = None</span><br>            <span class="hljs-comment"># 1. this node has No Left node, then pop this node and add into inorder</span><br>            <span class="hljs-comment"># And check if it has right node </span><br>            <span class="hljs-comment"># 2. If it has right node, then push the right node into stack and continue</span><br>            <span class="hljs-comment"># If it has No right node, then pop the anchor node</span><br>            <span class="hljs-keyword">while</span> node:<br>                stack.append(node)<br>                node = node.left<br><br>            node　= stack.pop()<br>            inorder.append(node.val)<br><br>            node = node.right<br>        <span class="hljs-keyword">return</span> inorder<br><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorderTraversal</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> []<br><br>        stack = []<br>        inorder = []<br>        node = root<br>        <span class="hljs-keyword">while</span> node <span class="hljs-keyword">or</span> stack:<br>            <span class="hljs-comment"># curr = None</span><br>            <span class="hljs-comment"># 1. this node has No Left node, then pop this node and add into inorder</span><br>            <span class="hljs-comment"># And check if it has right node </span><br>            <span class="hljs-comment"># 2. If it has right node, then push the right node into stack and continue</span><br>            <span class="hljs-comment"># If it has No right node, then pop the anchor node</span><br>            <span class="hljs-keyword">while</span> node:<br>                inorder.append(node.val)<br>                stack.append(node)<br>                node = node.left<br><br>            node　= stack.pop()<br>            node = node.right<br>        <span class="hljs-keyword">return</span> inorder<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorderTraversal</span>(<span class="hljs-params">self, root</span>):<br>        <br>        output, stack = [], []<br>        <br>        <span class="hljs-keyword">while</span> root <span class="hljs-keyword">or</span> stack:<br>            <span class="hljs-keyword">if</span> root:<br>                output.append(root.val)<br>                stack.append(root)<br>                root = root.left<br>            <span class="hljs-keyword">else</span>:<br>                root = stack.pop()<br>                root = root.right<br>        <br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure>


<ol start="3">
<li>Method3 Iteration<br>这个算法包括了两种操作：<br>第一个操作是把一整条向左的path都存入到stack里面，<br>第二个操作是寻找先驱节点。这个算法用到的一个重要的性质是：对于一个右子树，先驱节点到达它的方式一定是，先向左一下，（<br>到达进入右子树，但却已经被访问过的那个节点），再向右进入右子树，所以利用这个性质，所有stack-1 &#x3D;&#x3D; node的节点其实都是已经被printed的节点了，<br>不是真正的先驱节点。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    @param root: A Tree</span><br><span class="hljs-string">    @return: Inorder in ArrayList which contains node values.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> []<br>            <br>        <span class="hljs-comment"># 创建一个 dummy node，右指针指向 root</span><br>        <span class="hljs-comment"># 并放到 stack 里，此时 stack 的栈顶 dummy</span><br>        <span class="hljs-comment"># 是 iterator 的当前位置</span><br>        dummy = TreeNode(<span class="hljs-number">0</span>)<br>        dummy.right = root<br>        stack = [dummy]<br>            <br>        inorder = []<br>        <span class="hljs-comment"># 每次将 iterator 挪到下一个点</span><br>        <span class="hljs-comment"># 也就是调整 stack 使得栈顶到下一个点</span><br>        <span class="hljs-keyword">while</span> stack:<br>            node = stack.pop()<br>            <span class="hljs-keyword">if</span> node.right:<br>                node = node.right<br>                <span class="hljs-keyword">while</span> node:<br>                    stack.append(node)<br>                    node = node.left<br>            <span class="hljs-keyword">if</span> stack:<br>                inorder.append(stack[-<span class="hljs-number">1</span>].val)<br>                <br>        <span class="hljs-keyword">return</span> inorder<br></code></pre></td></tr></table></figure>


<ol start="3">
<li>Method4 Iteration<br>第四个解法（morris逻辑上很直接。这个算法的根本是：把一个子树的最右边的节点（最后一个被访问的节点）的右节点，连到它的先驱节点上。这样就避免了找先驱节点的麻烦，<br>相当于反向的思维解决了问题。算法是对于每一个节点，第一步是找它是谁的先驱节点，方法和2类似，就是找它左子树的最右边，首先如果没有左子树，直接print 然后向右走就行。<br>然后要分两种情况：</li>
<li>发现它左子树最右边是None，就把这个None改成它自己，向左走；</li>
<li>如果左子树的最右边是它自己，说明我要找的就是它，print 它，然后向右走<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal3</span>(<span class="hljs-params">self,root</span>):<br>    ans = []<br>    stack = []<br>    curr = root<br>    <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">or</span> curr:<br>        <span class="hljs-keyword">if</span> curr.left:<br>            pre = curr.left<br>            <span class="hljs-keyword">while</span> pre.right <span class="hljs-keyword">and</span> pre.right!=curr:<br>                pre = pre.right<br>            <span class="hljs-keyword">if</span> pre.right!=curr:<br>                pre.right = curr<br>                curr = curr.left<br>            <span class="hljs-keyword">else</span>:<br>                pre.right = <span class="hljs-literal">None</span><br>                ans.append(curr.val)<br>                curr = curr.right<br>        <span class="hljs-keyword">else</span>:<br>            ans.append(curr.val)<br>            curr = curr.right<br>    <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a>226. Invert Binary Tree</h4><ul>
<li>BFS</li>
<li>DFS: 递归过程中直接交换当前节点的左右子树，构造新的二叉树返回即可。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># BFS</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val</span>):<br>        self.val = val<br>        self.left, self.right = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    @param root: a TreeNode, the root of the binary tree</span><br><span class="hljs-string">    @return: nothing</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invertBinaryTree</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-comment"># write your code here</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span><br>        <br>        queue = collections.deque([root])<br>        <span class="hljs-keyword">while</span> queue:<br>            node = queue.popleft()<br>            node.left, node.right = node.right, node.left<br>            <span class="hljs-keyword">if</span> node.left:<br>                queue.append(node.left)<br>            <span class="hljs-keyword">if</span> node.right:<br>                queue.append(node.right)<br><br><br><span class="hljs-comment"># DFS</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invertTree</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>        self.dfs(root)<br>        <span class="hljs-keyword">return</span> root<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">self,root</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        left = root.left<br>        right = root.right<br>        root.left = right<br>        root.right = left<br>        <span class="hljs-keyword">if</span> root.left: self.dfs(root.left)<br>        <span class="hljs-keyword">if</span> root.right: self.dfs(root.right)<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h4 id="204-Count-Primes"><a href="#204-Count-Primes" class="headerlink" title="204. Count Primes"></a>204. Count Primes</h4><ul>
<li>Initialize a list Prime &#x3D; [True] * n –&gt; Assume all the number from 1 to n are all prime.</li>
<li>Traverse from 2 to √n and if number i is True in prime list, then set all the numbers have factor i as False.<br>Which means all the number from ixi, ix(i+1), ix(i+2), …, n shoube be False in Prime array.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countPrimes</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        prime = [<span class="hljs-literal">True</span>] * n<br>        prime[<span class="hljs-number">0</span>] = <span class="hljs-literal">False</span><br>        prime[<span class="hljs-number">1</span>] = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-built_in">int</span>(n**<span class="hljs-number">0.5</span>)+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> prime[i]:<br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i*i, n, i):<br>                    prime[j] = <span class="hljs-literal">False</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(prime)<br><br></code></pre></td></tr></table></figure>

<h4 id="Leetcode-5-Longest-Palindromic-Substring"><a href="#Leetcode-5-Longest-Palindromic-Substring" class="headerlink" title="Leetcode 5. Longest Palindromic Substring"></a>Leetcode 5. Longest Palindromic Substring</h4><ul>
<li><p>Method1 暴力法 O(n**3)</p>
</li>
<li><p>Method2 枚举中心法</p>
<ul>
<li>时间复杂度<ul>
<li>枚举回文中心，复杂度 O(n)。</li>
<li>向两边延展并 check，复杂度 O(n)。</li>
<li>总时，时间复杂度为 O(n^2)</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(1)</li>
</ul>
</li>
</ul>
</li>
<li><p>Method3 动态规划</p>
<ul>
<li>dp(l,r): 代表区间[l,r]是否是回文串</li>
<li>如果s[l] &#x3D;&#x3D; s[r] and dp(l+1,r-1) &#x3D; True –&gt; dp(l,r) &#x3D; True</li>
<li>Complexity:</li>
<li>Time O(n^2)</li>
<li>Space O(n^2)</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Method2 枚举中心法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s</span>):<br>    <span class="hljs-comment"># 重点1：任何代码都要进行异常检测</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>    <br>    <span class="hljs-comment"># 重点2：用空行区分开异常检测部分，核心代码部分，和返回值部分，属于高端代码风格技巧</span><br>    longest = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> middle <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>        <span class="hljs-comment"># 重点3：子函数化避免重复代码</span><br>        sub = self.find_palindrome_from(s, middle, middle)<br>        <span class="hljs-comment"># 重点4：通过返回值来避免使用全局变量这种不好的代码风格</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sub) &gt; <span class="hljs-built_in">len</span>(longest):<br>            longest = sub<br>        sub = self.find_palindrome_from(s, middle, middle + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sub) &gt; <span class="hljs-built_in">len</span>(longest):<br>            longest = sub<br>            <br>    <span class="hljs-comment"># 重点2：用空行区分开异常检测部分，核心代码部分，和返回值部分，属于高端代码风格技巧</span><br>    <span class="hljs-keyword">return</span> longest<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_palindrome_from</span>(<span class="hljs-params">self, string, left, right</span>):<br>    <span class="hljs-keyword">while</span> left &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> right &lt; <span class="hljs-built_in">len</span>(string):<br>        <span class="hljs-comment"># 重点5：将复杂判断拆分到 while 循环内部，而不是放在 while 循环中，提高代码可读性</span><br>        <span class="hljs-keyword">if</span> string[left] != string[right]:<br>            <span class="hljs-keyword">break</span><br>        left -= <span class="hljs-number">1</span><br>        right += <span class="hljs-number">1</span><br>        <br>    <span class="hljs-keyword">return</span> string[left + <span class="hljs-number">1</span>:right]<br><br><br><span class="hljs-comment"># Method3 动态规划</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-comment"># 动态规划</span><br>        max_len = <span class="hljs-number">1</span> <br>        n = <span class="hljs-built_in">len</span>(s)<br>        left = <span class="hljs-number">0</span><br>        <br>        <span class="hljs-comment"># is_p 记录s[start:end]的substring是否是回文串</span><br>        is_p = [[<span class="hljs-literal">False</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <br>        <span class="hljs-comment"># 长度为1，is_p = true</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            is_p[i][i] = <span class="hljs-literal">True</span><br>        <br>        <span class="hljs-comment">#  找到长度为2的回文串的下标, is_p[i][i+1] = True</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> s[i] == s[i+<span class="hljs-number">1</span>]:<br>                is_p[i][i+<span class="hljs-number">1</span>] = <span class="hljs-literal">True</span><br>                max_len = <span class="hljs-number">2</span><br>                left = i<br><br>        <span class="hljs-comment"># 从长度为3开始找</span><br>        <span class="hljs-keyword">for</span> length <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>,n+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> start <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-length+<span class="hljs-number">1</span>):<br>                end = start + length -<span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> s[start] == s[end] <span class="hljs-keyword">and</span> is_p[start+<span class="hljs-number">1</span>][end-<span class="hljs-number">1</span>]:<br>                    is_p[start][end] = <span class="hljs-literal">True</span> <br>                    <span class="hljs-comment"># update the answer</span><br>                    <span class="hljs-keyword">if</span> length &gt; max_len:<br>                        max_len = length<br>                        left = start<br>        <br>        <span class="hljs-keyword">return</span> s[left:left+max_len]<br></code></pre></td></tr></table></figure>

<h4 id="Leetcode-6-Zigzag-Conversion"><a href="#Leetcode-6-Zigzag-Conversion" class="headerlink" title="Leetcode 6. Zigzag Conversion"></a>Leetcode 6. Zigzag Conversion</h4><ul>
<li>一个loop的长度为2*n - 2</li>
<li>通过index%loop的余数可以判断当前index应该处于哪一行</li>
<li>如果余数&lt; row number –&gt; 余数就是对应的行数</li>
<li>如果余数 ≥ row number –&gt; loop - 余数作为行数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">convert</span>(<span class="hljs-params">self, s, numRows</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type numRows: int</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> numRows &lt;= <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> numRows &gt;= <span class="hljs-built_in">len</span>(s):<br>            <span class="hljs-keyword">return</span> s<br>        arr = [<span class="hljs-string">&#x27;&#x27;</span>] * numRows<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-built_in">len</span>(s)):<br>            tmp = i % (numRows + numRows - <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">if</span> tmp &lt; numRows:<br>                arr[tmp] += s[i]<br>            <span class="hljs-keyword">else</span>:<br>                arr[numRows + numRows - <span class="hljs-number">2</span> - tmp] += s[i]<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(arr)<br></code></pre></td></tr></table></figure>

<h4 id="Leetcode-10-Regular-Expression-Matching"><a href="#Leetcode-10-Regular-Expression-Matching" class="headerlink" title="Leetcode 10. Regular Expression Matching"></a>Leetcode 10. Regular Expression Matching</h4><ul>
<li>记忆化搜索|| dp</li>
<li>题解：<br>采用字典hash记录各处字符匹配情况，dfs递归进行搜索，记忆化剪枝<br>dp使用数组记忆化，实现合理的状态转移<br>当前p串中有*，就有两种选择，然后 可以不去匹配，直接用p串的下一个匹配当前s串字符，或者重复p串的上一个字符匹配。<br>.可以匹配任意字符</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    @param s: A string </span><br><span class="hljs-string">    @param p: A string includes &quot;?&quot; and &quot;*&quot;</span><br><span class="hljs-string">    @return: is Match?</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isMatch</span>(<span class="hljs-params">self, source, pattern</span>):<br>        <span class="hljs-keyword">return</span> self.is_match_helper(source, <span class="hljs-number">0</span>, pattern, <span class="hljs-number">0</span>, &#123;&#125;)<br>        <br>        <br>    <span class="hljs-comment"># source 从 i 开始的后缀能否匹配上 pattern 从 j 开始的后缀</span><br>    <span class="hljs-comment"># 能 return True</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_match_helper</span>(<span class="hljs-params">self, source, i, pattern, j, memo</span>):<br>        <span class="hljs-keyword">if</span> (i, j) <span class="hljs-keyword">in</span> memo:<br>            <span class="hljs-keyword">return</span> memo[(i, j)]<br>        <br>        <span class="hljs-comment"># source is empty</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(source) == i:<br>            <span class="hljs-keyword">return</span> self.is_empty(pattern[j:])<br><br>        <span class="hljs-comment"># if souce is not empty but pattern is empty then return False    </span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pattern) == j:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-comment"># source:  aaaaaaaabc</span><br>        <span class="hljs-comment"># pattern: a*bc -&gt; aabc</span><br>        <span class="hljs-comment"># handel * 可以代表任意多个前面的字母的情况，可以比较如果s[i] = p[j], 则i一直往后移动，直到s[i] != p[j]</span><br>        <span class="hljs-comment"># check此时s[i]与p[j]开始的后缀是否可以匹配</span><br>        <span class="hljs-keyword">if</span> j + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(pattern) <span class="hljs-keyword">and</span> pattern[j + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>:<br>            matched = self.is_match_char(source[i], pattern[j]) <span class="hljs-keyword">and</span> self.is_match_helper(source, i + <span class="hljs-number">1</span>, pattern, j, memo) <span class="hljs-keyword">or</span> \<br>                <span class="hljs-comment"># 把 &#x27;x*&#x27; 作为一个整体匹配 0 个 &#x27;x&#x27; 也就是 &quot;&quot;</span><br>                self.is_match_helper(source, i, pattern, j + <span class="hljs-number">2</span>, memo)<br>        <span class="hljs-keyword">else</span>: <br>            <span class="hljs-comment"># source: ab</span><br>            <span class="hljs-comment"># pattern xy/ ay --&gt;必须 a=x and  is_match_helper(source, i + 1, pattern, j + 1, memo)             </span><br>            matched = self.is_match_char(source[i], pattern[j]) <span class="hljs-keyword">and</span> self.is_match_helper(source, i + <span class="hljs-number">1</span>, pattern, j + <span class="hljs-number">1</span>, memo)<br>        <br>        memo[(i, j)] = matched<br>        <span class="hljs-keyword">return</span> matched<br>        <br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_match_char</span>(<span class="hljs-params">self, s, p</span>):<br>        <span class="hljs-keyword">return</span> s == p <span class="hljs-keyword">or</span> p == <span class="hljs-string">&#x27;.&#x27;</span><br><br>    <span class="hljs-comment"># check if pattern could be empty or not</span><br>    <span class="hljs-comment"># only pattern like x*x*x* could be empty</span><br>    <span class="hljs-comment"># So if the length of pattern is odd, then it could not be empty</span><br>    <span class="hljs-comment"># And only of all odd index of the pattern is &#x27;*&#x27; then pattern could be empty</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_empty</span>(<span class="hljs-params">self, pattern</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pattern) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(pattern) // <span class="hljs-number">2</span>):<br>            <span class="hljs-keyword">if</span> pattern[i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;*&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>


<h4 id="Leetcode-12-Integer-to-Roman"><a href="#Leetcode-12-Integer-to-Roman" class="headerlink" title="Leetcode 12. Integer to Roman"></a>Leetcode 12. Integer to Roman</h4><ul>
<li>Find the right cutpoints<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Method1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">intToRoman</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:     <br>        values = [ <span class="hljs-number">1000</span>, <span class="hljs-number">900</span>, <span class="hljs-number">500</span>, <span class="hljs-number">400</span>, <span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">50</span>, <span class="hljs-number">40</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span> ]<br>        numerals = [ <span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;CM&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;CD&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;XC&quot;</span>, <span class="hljs-string">&quot;L&quot;</span>, <span class="hljs-string">&quot;XL&quot;</span>, <span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;IX&quot;</span>, <span class="hljs-string">&quot;V&quot;</span>, <span class="hljs-string">&quot;IV&quot;</span>, <span class="hljs-string">&quot;I&quot;</span> ]<br>        res = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(values):<br>            res += (num//v) * numerals[i]<br>            num %= v<br>        <span class="hljs-keyword">return</span> res<br><br><span class="hljs-comment"># Method2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">intToRoman</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:     <br>        M = [<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;MM&quot;</span>, <span class="hljs-string">&quot;MMM&quot;</span>]<br>        C = [<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;CC&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>, <span class="hljs-string">&quot;CD&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;DC&quot;</span>, <span class="hljs-string">&quot;DCC&quot;</span>, <span class="hljs-string">&quot;DCCC&quot;</span>, <span class="hljs-string">&quot;CM&quot;</span>]<br>        X = [<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;XX&quot;</span>, <span class="hljs-string">&quot;XXX&quot;</span>, <span class="hljs-string">&quot;XL&quot;</span>, <span class="hljs-string">&quot;L&quot;</span>, <span class="hljs-string">&quot;LX&quot;</span>, <span class="hljs-string">&quot;LXX&quot;</span>, <span class="hljs-string">&quot;LXXX&quot;</span>, <span class="hljs-string">&quot;XC&quot;</span>]<br>        I = [<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;II&quot;</span>, <span class="hljs-string">&quot;III&quot;</span>, <span class="hljs-string">&quot;IV&quot;</span>, <span class="hljs-string">&quot;V&quot;</span>, <span class="hljs-string">&quot;VI&quot;</span>, <span class="hljs-string">&quot;VII&quot;</span>, <span class="hljs-string">&quot;VIII&quot;</span>, <span class="hljs-string">&quot;IX&quot;</span>]<br>        <span class="hljs-keyword">return</span> M[num//<span class="hljs-number">1000</span>] + C[(num%<span class="hljs-number">1000</span>)//<span class="hljs-number">100</span>]+ X[(num%<span class="hljs-number">100</span>)//<span class="hljs-number">10</span>] + I[num%<span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="Leetcode-966-Vowel-Spellchecker"><a href="#Leetcode-966-Vowel-Spellchecker" class="headerlink" title="Leetcode 966. Vowel Spellchecker"></a>Leetcode 966. Vowel Spellchecker</h4><p>For each word in the wordlist,<br>get its the lower pattern and devowel pattern,</p>
<p>For each lower pattern, record the first such match to hashmap cap.<br>For each vowel pattern, record the first such match to hashmap vowel.</p>
<p>For each query,<br>check if it’s in the words set,<br>check if there is a match in cap,<br>check if there is a match in vowel,<br>otherwise return “”.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Method 1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spellchecker</span>(<span class="hljs-params">self, wordlist, queries</span>):<br>    words = &#123;w: w <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> wordlist&#125;<br>    cap = &#123;w.lower(): w <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> wordlist[::-<span class="hljs-number">1</span>]&#125;<br>    vowel = &#123;re.sub(<span class="hljs-string">&quot;[aeiou]&quot;</span>, <span class="hljs-string">&#x27;#&#x27;</span>, w.lower()): w <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> wordlist[::-<span class="hljs-number">1</span>]&#125;<br>    <span class="hljs-keyword">return</span> [words.get(w) <span class="hljs-keyword">or</span> cap.get(w.lower()) <span class="hljs-keyword">or</span> vowel.get(re.sub(<span class="hljs-string">&quot;[aeiou]&quot;</span>, <span class="hljs-string">&#x27;#&#x27;</span>, w.lower()), <span class="hljs-string">&quot;&quot;</span>) <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> queries]<br><br><br><span class="hljs-comment"># Method 2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spellchecker</span>(<span class="hljs-params">self, wordlist, queries</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">mask</span>(<span class="hljs-params">w</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-keyword">if</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;aeiou&#x27;</span> <span class="hljs-keyword">else</span> c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> w.lower())<br>        <br>        d0 = <span class="hljs-built_in">set</span>(wordlist)<br>        d1 = &#123;w.lower(): w <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> wordlist[::-<span class="hljs-number">1</span>]&#125;<br>        d2 = &#123;mask(w): w <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> wordlist[::-<span class="hljs-number">1</span>]&#125;<br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>(<span class="hljs-params">query</span>):<br>            <span class="hljs-keyword">if</span> query <span class="hljs-keyword">in</span> d0: <span class="hljs-keyword">return</span> query<br>            <span class="hljs-keyword">if</span> query.lower() <span class="hljs-keyword">in</span> d1: <span class="hljs-keyword">return</span> d1[query.lower()]<br>            <span class="hljs-keyword">if</span> mask(query) <span class="hljs-keyword">in</span> d2: <span class="hljs-keyword">return</span> d2[mask(query)]<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>        <br>        <span class="hljs-keyword">return</span> [solve(q) <span class="hljs-keyword">for</span> q <span class="hljs-keyword">in</span> queries]<br></code></pre></td></tr></table></figure>


<h4 id="Python-Regular-Expression"><a href="#Python-Regular-Expression" class="headerlink" title="Python Regular Expression"></a>Python Regular Expression</h4><ul>
<li>import re<br>Function    Description</li>
</ul>
<p>findall        Returns a list containing all matches<br>search        Returns a Match object if there is a match anywhere in the string</p>
<ul>
<li>The search() function searches the string for a match, and returns a Match object if there is a match.</li>
<li>A Match Object is an object containing information about the search and the result.<ul>
<li>.span() returns a tuple containing the start-, and end positions of the match.</li>
<li>.string returns the string passed into the function</li>
<li>.group() returns the part of the string where there was a match</li>
</ul>
</li>
</ul>
<p>If there is more than one match, only the first occurrence of the match will be returned:<br>split        Returns a list where the string has been split at each match<br>sub            Replaces one or many matches with a string</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python">txt = <span class="hljs-string">&quot;The rain in Spain&quot;</span><br>x = re.search(<span class="hljs-string">&quot;^The.*Spain$&quot;</span>, txt)<br><span class="hljs-built_in">print</span>(x)<br>&lt;re.Match <span class="hljs-built_in">object</span>; span=(<span class="hljs-number">0</span>, <span class="hljs-number">17</span>), match=<span class="hljs-string">&#x27;The rain in Spain&#x27;</span>&gt;<br><br>txt = <span class="hljs-string">&quot;The rain in Spain&quot;</span><br>x = re.findall(<span class="hljs-string">&quot;ai&quot;</span>, txt)<br><span class="hljs-built_in">print</span>(x) <br>[<span class="hljs-string">&#x27;ai&#x27;</span>,<span class="hljs-string">&#x27;ai&#x27;</span>]<br><br>txt = <span class="hljs-string">&quot;The rain in Spain&quot;</span><br>x = re.findall(<span class="hljs-string">&quot;Portugal&quot;</span>, txt)<br><span class="hljs-built_in">print</span>(x)<br>[]<br><br>txt = <span class="hljs-string">&quot;The rain in Spain&quot;</span><br>x = re.search(<span class="hljs-string">&quot;\s&quot;</span>, txt)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The first white-space character is located in position:&quot;</span>, x.start())<br><br><span class="hljs-comment"># Split at each white-space character</span><br>txt = <span class="hljs-string">&quot;The rain in Spain&quot;</span><br>x = re.split(<span class="hljs-string">&quot;\s&quot;</span>, txt)<br><span class="hljs-built_in">print</span>(x)<br>[<span class="hljs-string">&#x27;The&#x27;</span>, <span class="hljs-string">&#x27;rain&#x27;</span>, <span class="hljs-string">&#x27;in&#x27;</span>, <span class="hljs-string">&#x27;Spain&#x27;</span>]<br><br><span class="hljs-comment"># Split the string only at the first occurrence:</span><br>txt = <span class="hljs-string">&quot;The rain in Spain&quot;</span><br>x = re.split(<span class="hljs-string">&quot;\s&quot;</span>, txt, <span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(x)<br><br>txt = <span class="hljs-string">&quot;The rain in Spain&quot;</span><br>x = re.sub(<span class="hljs-string">&quot;\s&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>, txt)<br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-string">&#x27;The9rain9in9Spain&#x27;</span><br><br><span class="hljs-comment"># Replace the first 2 occurrences</span><br>txt = <span class="hljs-string">&quot;The rain in Spain&quot;</span><br>x = re.sub(<span class="hljs-string">&quot;\s&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>, txt, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-string">&#x27;The9rain9in Spain&#x27;</span><br><br><span class="hljs-comment"># return Match object</span><br>txt = <span class="hljs-string">&quot;The rain in Spain&quot;</span><br>x = re.search(<span class="hljs-string">&quot;ai&quot;</span>, txt)<br><span class="hljs-built_in">print</span>(x)<br>&lt;re.Match <span class="hljs-built_in">object</span>; span=(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>), match=<span class="hljs-string">&#x27;ai&#x27;</span>&gt;<br><span class="hljs-built_in">print</span>(x.span())<br><span class="hljs-built_in">print</span>(x.string)<br><span class="hljs-built_in">print</span>(x.group())<br>(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>)<br>The rain <span class="hljs-keyword">in</span> Spain<br>ai<br><br><span class="hljs-comment">#Search for an upper case &quot;S&quot; character in the beginning of a word, and print its position:</span><br><br>txt = <span class="hljs-string">&quot;The rain in Spain&quot;</span><br>x = re.search(<span class="hljs-string">r&quot;\bS\w+&quot;</span>, txt)<br><span class="hljs-built_in">print</span>(x.span())<br><br></code></pre></td></tr></table></figure>








<h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><h4 id="Leetcode-300-Longest-Increasing-Subsequence"><a href="#Leetcode-300-Longest-Increasing-Subsequence" class="headerlink" title="Leetcode 300. Longest Increasing Subsequence"></a>Leetcode 300. Longest Increasing Subsequence</h4><ul>
<li><p>Method1 - DP</p>
<ol>
<li>Time Complexity O(n^2)</li>
<li>Dpi 表示以第i个数字为结尾的最长上升子序列的长度。 对于每个数字，枚举前面所有小于自己的数字 j，<br> Dpi &#x3D; max{Dpj} + 1. 如果没有比自己小的，Dpi &#x3D; 1</li>
</ol>
</li>
<li><p>Method2 - DP + 二分优化</p>
<ol>
<li>Time Complexity O(nlogn)</li>
<li>使用一个辅助空间B数组。 Bi存储Dp值为i的最小的数字。（有多个位置，以这些位置为结尾的LIS长度都为i， 则这些数字中最小的一个存在Bi中）<br>则B数组严格递增。且下标表示LIS长度，也是严格递增，可以在B数组中进行二分查找。<br>对于每个位置i，我们要找，所有小于Ai, 且Dp值最大的那个。这个操作在B数组中二分查找。</li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Method1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    @param nums: The integer array</span><br><span class="hljs-string">    @return: The length of LIS (longest increasing subsequence)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestIncreasingSubsequence</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-comment"># write your code here</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-comment"># dp[i]表示以nums[i]为结尾的最长上身子序列的长度</span><br>        <span class="hljs-comment"># 初始值为1</span><br>        dp = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                <span class="hljs-comment"># 若nums[j] &lt; nums[i]那么可以接在该序列后，更新状态</span><br>                <span class="hljs-keyword">if</span> nums[j] &lt; nums[i]:<br>                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># 答案为所有状态中的最大值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br><br><span class="hljs-comment"># Method1 - Add path</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    @param nums: The integer array</span><br><span class="hljs-string">    @return: The length of LIS (longest increasing subsequence)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestIncreasingSubsequence</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-keyword">if</span> nums <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> nums:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        <span class="hljs-comment"># state: dp[i] 表示从左到右跳到i的最长sequence 的长度</span><br>        <br>        <span class="hljs-comment"># initialization: dp[0..n-1] = 1</span><br>        dp = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(nums)<br>        <br>        <span class="hljs-comment"># prev[i] 代表 dp[i] 的最优值是从哪个 dp[j] 算过来的</span><br>        prev = [-<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(nums)<br>        <br>        <span class="hljs-comment"># function dp[i] = max&#123;dp[j] + 1&#125;,  j &lt; i and nums[j] &lt; nums[i]</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                <span class="hljs-keyword">if</span> nums[j] &lt; nums[i] <span class="hljs-keyword">and</span> dp[i] &lt; dp[j] + <span class="hljs-number">1</span>:<br>                    dp[i] = dp[j] + <span class="hljs-number">1</span><br>                    prev[i] = j<br>        <br>        <span class="hljs-comment"># answer: max(dp[0..n-1])</span><br>        longest, last = <span class="hljs-number">0</span>, -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> dp[i] &gt; longest:<br>                longest = dp[i]<br>                last = i<br>        <br>        path = []<br>        <span class="hljs-keyword">while</span> last != -<span class="hljs-number">1</span>:<br>            path.append(nums[last])<br>            last = prev[last]<br>        <span class="hljs-built_in">print</span>(path[::-<span class="hljs-number">1</span>])<br>        <br>        <span class="hljs-keyword">return</span> longest<br><br><span class="hljs-comment"># Method2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    @param nums: The integer array</span><br><span class="hljs-string">    @return: The length of LIS (longest increasing subsequence)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestIncreasingSubsequence</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-comment"># b[i]表示长度为i的最长上升子序列的末尾元素的最小值。b数组一定单调递增</span><br>        <span class="hljs-comment"># 长度为0的最长上升子序列的末尾元素的最小值为-inf</span><br>        <span class="hljs-comment"># index为当前数字为最小结尾的最长上升子序列的最长长度</span><br>        <span class="hljs-comment"># 根据index更新全局最大值</span><br>        b = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)] * (<span class="hljs-built_in">len</span>(nums) + <span class="hljs-number">1</span>)<br>        b[<span class="hljs-number">0</span>] = -<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>        <br>        longest = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>            index = self.first_gte(b, num)<br>            b[index] = num<br>            longest = <span class="hljs-built_in">max</span>(longest, index)<br>        <br>        <span class="hljs-keyword">return</span> longest<br>        <br>    <span class="hljs-comment"># find first index that the number greater than or equal to num</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">first_gte</span>(<span class="hljs-params">self, nums, target</span>):<br>        start, end = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> start + <span class="hljs-number">1</span> &lt; end:<br>            mid = (start + end) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> nums[mid] &gt;= target:<br>                end = mid<br>            <span class="hljs-keyword">else</span>:<br>                start = mid<br>        <span class="hljs-keyword">if</span> nums[start] &gt;= target:<br>            <span class="hljs-keyword">return</span> start<br>        <span class="hljs-keyword">return</span> end<br></code></pre></td></tr></table></figure>




      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>Zoe</li>
    <li><strong>本文链接：</strong><a href="http://cs-stat.herokuapp.com/2022/05/23/leetcode/index.html" title="http:&#x2F;&#x2F;cs-stat.herokuapp.com&#x2F;2022&#x2F;05&#x2F;23&#x2F;leetcode&#x2F;index.html">http:&#x2F;&#x2F;cs-stat.herokuapp.com&#x2F;2022&#x2F;05&#x2F;23&#x2F;leetcode&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
          <section class="donate">
  <div id="qrcode-donate">
    <img   class="lazyload" data-original="https://pic.izhaoo.com/alipay.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linked-List/" rel="tag">Linked List</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Merge-Sort/" rel="tag">Merge Sort</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul> 

        
  <nav class="nav">
    <a href="/2022/05/28/weekly-contest-295/"><i class="iconfont iconleft"></i>weekly-contest-295</a>
    <a href="/2022/05/22/weekly-contest-294/">weekly-contest-294<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrays-and-Hashing"><span class="toc-text">Arrays and Hashing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-36-Valid-Sudoku"><span class="toc-text">Leetcode 36 Valid Sudoku</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-128-Longest-Consecutive-Sequence"><span class="toc-text">Leetcode 128 Longest Consecutive Sequence</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-125-Valid-Palindrome"><span class="toc-text">Leetcode 125. Valid Palindrome</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-15-3Sum"><span class="toc-text">Leetcode 15. 3Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-11-Container-With-Most-Water"><span class="toc-text">Leetcode 11. Container With Most Water</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-42-Trapping-Rain-Water"><span class="toc-text">Leetcode 42. Trapping Rain Water</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Sliding-Window"><span class="toc-text">Sliding Window</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-121-Best-Time-to-Buy-and-Sell-Stock"><span class="toc-text">Leetcode 121. Best Time to Buy and Sell Stock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-3-Longest-Substring-Without-Repeating-Characters"><span class="toc-text">Leetcode 3. Longest Substring Without Repeating Characters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-424-Longest-Repeating-Character-Replacement"><span class="toc-text">Leetcode 424. Longest Repeating Character Replacement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-567-Permutation-in-String"><span class="toc-text">Leetcode 567. Permutation in String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-76-Minimum-Window-Substring"><span class="toc-text">Leetcode 76. Minimum Window Substring</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Stack"><span class="toc-text">Stack</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Binary-Search"><span class="toc-text">Binary Search</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E7%89%88"><span class="toc-text">模版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86%E6%B3%95%E6%A8%A1%E7%89%88"><span class="toc-text">整数二分法模版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E4%BA%8C%E5%88%86%E6%A8%A1%E7%89%88"><span class="toc-text">九章算法二分模版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#import-bisect"><span class="toc-text">import bisect</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DFS"><span class="toc-text">DFS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Tree-Traversal"><span class="toc-text">Tree Traversal</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#String"><span class="toc-text">String</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DP"><span class="toc-text">DP</span></a>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="tencent://message/?Menu=yes&uin=894519210 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#12B7F5'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconQQ "></i>
      </a><a 
        href="javascript:; "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#09BB07'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconwechat-fill "></i>
      </a><a 
        href="https://www.instagram.com/izhaoo/ "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#DA2E76'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconinstagram "></i>
      </a><a 
        href="https://github.com/zhaoo "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:izhaoo@163.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/js/color-mode.js"></script>

  
  
</body>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>





  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>